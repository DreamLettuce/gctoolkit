diff --git a/.github/workflows/maven.yml b/.github/workflows/maven.yml
index 5b3d6af..3cf9dfb 100644
--- a/.github/workflows/maven.yml
+++ b/.github/workflows/maven.yml
@@ -1,9 +1,6 @@
 name: GCToolKit build with Maven
 
 on:
-  workflow_dispatch:
-  schedule:
-    - cron: 0 0 * * *
   push:
     branches: [ main ]
     paths-ignore:
diff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml
index af7d2a1..df8e1b0 100644
--- a/.github/workflows/publish.yml
+++ b/.github/workflows/publish.yml
@@ -13,6 +13,7 @@ jobs:
         uses: actions/checkout@v2
         with:
           ref: main
+          fetch-depth: 0
 
       - name: Cache Maven
         uses: actions/cache@v2.1.4
@@ -36,7 +37,14 @@ jobs:
         run: |
           git config user.email "actions@github.com"
           git config user.name "GitHub Actions"
-          
+
+      - name: Version
+        id: version
+        run: |
+          release_version=$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout)
+          release_version=${release_version%-*}
+          echo ::set-output name=version::${release_version}
+
       - name: Release
         run: |
           export GPG_TTY=$(tty)
@@ -46,4 +54,12 @@ jobs:
         env:
           MAVEN_USERNAME: ${{ secrets.SONATYPE_NAME }}
           MAVEN_CENTRAL_TOKEN: ${{ secrets.SONATYPE_PASSWORD }}
-          MAVEN_GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
\ No newline at end of file
+          MAVEN_GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
+
+      - name: Git-release
+        run: |
+          ./mvnw -B versions:set -DnewVersion=${{steps.version.outputs.version}}
+          ./mvnw -B -pl :gctoolkit -Pjreleaser jreleaser:release
+
+        env:
+          JRELEASER_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
diff --git a/.mvn/wrapper/maven-wrapper.properties b/.mvn/wrapper/maven-wrapper.properties
index 598fb34..abd303b 100644
--- a/.mvn/wrapper/maven-wrapper.properties
+++ b/.mvn/wrapper/maven-wrapper.properties
@@ -1,2 +1,2 @@
-distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.8.4/apache-maven-3.8.4-bin.zip
+distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.8.2/apache-maven-3.8.2-bin.zip
 wrapperUrl=https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar
diff --git a/DEVELOPERS_GUIDE.md b/DEVELOPERS_GUIDE.md
new file mode 100644
index 0000000..1f85ee5
--- /dev/null
+++ b/DEVELOPERS_GUIDE.md
@@ -0,0 +1,91 @@
+# Microsoft GCToolKit Developers Guide
+
+---
+
+## Introduction
+
+GCToolkit is comprised of 3 Java modules, vertx, parser, and api. This document describes how each of these modules fits together to support the conversion of a garbage collection log to a stream of garbage collection events.
+Additionally, GCToolkit contains several components that perform the heavy lifting. These components include, a framework to interact with data sources, diary, data source bus, parsers, and event source bus and finally, a framework to support the aggregation of events.
+The purpose of this document is to provide a brief description of each of these components to aid in the further development of this toolkit.
+
+![GCToolkit Design](images/gctoolkit_design.png)
+Fig 1. GCToolKit Component Map
+
+<todo: Link to javadoc?>
+
+### Vert.x Message Bus and Verticles
+
+GCToolkit contains 2 different configurations of a Vert.x event bus. The first configuration supports the publishing of log lines. The second supports the publishing of GCEvent objects. GCEvent objects which will be covered in an upcoming section of this document.
+
+A second feature of Vert.x that GCToolkit is dependent on is the construct of a Verticle. A verticle acts as a container to encapsulate a component designed to process events. In GCToolkit vertices are used to encapsulate the DataSource, parsers, and aggregators. Vert.x takes care of many of the concerns that one has when distributing the processing events. In addition, verticals are a covenant abstraction that nicely supports strong separation of concerns.
+
+ 
+### Data Source 
+
+DataSource is an interface that allows one to define specializations for a source of GC events that maybe of interest. Currently the toolkit contains two data sources, a FileDataSource and a SafepointogFile. A GClogFile is a specialization of a FileDataSource. This is in turn has two specializations, SingleGCLogFIle and RotatingGCLogFile. The concrete classes take care of the details of being able to create a continuous stream of their contents.
+
+Another role of the DataSource is to provide a Diary (or summary) of important features found in the data. This would include information such as, is this a unified log or a pre-unified log, which version of the JVM produced the file. What flags where used to produce the file, which collector (combinations) are in play and so on. This information is used to construct the data paths through GCToolkit. It may also be used by clients of GCToolkit for their own purposes. For example, analytics may use the information to modulate how they process data.
+
+An example of this would be an analytic that looked at System.gc() behaviour. In JDK 1.7.0_40 the logs stopped reporting user triggered collections unless a new flag was enabled. This left the analytic blind to these events. In JDK 1.8.0, this new flag was automatically turned on when the PrintGCDetails flag was set. Making the analytics aware of the JDK version allowed them to calculate when System.gc() was likely being called thus enabling the analysis when the cause was missing in the log.
+
+###Parsers
+
+The parsers extract information from the log files and generation JVMEvents. All JVMEvents share the same 3 characteristics; the type of the event (reflected in the class), the time of the event, and the duration of the event. These properties are immutable and as such, the creation of a JVMEvent is delayed until they are known. The parse rules make heavy use of regular expressions. This is done so that the parser can make a best effort to extract information from a log even if that log is mixed with output from an unexpected source of the log or, the logs lines are some how corrupted.
+
+The currently existing parsers are generational, G1, Z, and Shenandoah. The generational parser cover the serial, parallel (PSYoung, PSOld), ParNew, CMS, and iCMS collectors. There are separate parsers for unified and pre-unified logs produced by the generational and G1 collectors. The pre-unified generational collectors should cope with logs produced by JDK 1.4.2 whereas the G1 log parsers are for JDK 8+. ZGC support starts at JDK 16 whereas Shenandoah starts at JDK 11.
+
+The flow through the parser starts with it accepting a log line. The line is run through a set of filters designed to recognize if we are interested in parsing it or not. If we are interested, the line is run over a set of regular expressions encapsulated in a class called GCParseRule. If the line hits a GCParseRule, a corresponding parse method is called. The values extracted from the log lines will be stored in a forward reference. This forward reference will be called upon to create the event once all of the lines for that GC event have been scanned. The event is then published on the JVMEvent message bus.
+
+An example of a GCParseRule can be seen in the code fragment below.
+
+
+GCParseRule CONCURRENT_CYCLE_END = new GCParseRule("CONCURRENT_CYCLE_END", "Concurrent Cycle " + CONCURRENT_TIME);
+
+This rule is designed to capture the unified log message (as can be seen below) that signals the normal completion of a concurrent cycle. All GCParseRules are designed to capture either a single line or a group of strongly related lines.
+
+[73.171s][info ][gc            ] GC(263) Concurrent Cycle 89.437ms
+
+If we look at the rule we can see that it has a name followed by a regular expression pattern. The pattern in this case has bee built up with the customer clause “Concurrent Cycle “ which is then followed by the String CONCURRENT_TIME. CONCURRENT_TIME is defined to be the same format as PAUSE_TIME. PAUSE_TIME is defined as TIME followed by 0 or 1 space which is then followed by either sec, secs or ms. TIME is an optional negative sign (“-“ followed by a REAL_NUMBER. The number is contained within a regex capture group. A REAL_NUMBER is an INTEGER followed by a decimal separator (. or ,) and another INTEGER value. Finally, INTEGER is defined as a sequence of numbers of length 1 or more.
+
+String CONCURRENT_TIME = PAUSE_TIME;
+String PAUSE_TIME = TIME + "\\s?(?:secs?|ms)";
+String TIME = "(-?" + REAL_NUMBER + “)";
+String REAL_NUMBER = INTEGER + DECIMAL_POINT + INTEGER;
+String DECIMAL_POINT = "(?:\\.|,)";
+String INTEGER = "\\d+";
+
+Since many lines contain either a pause or concurrent time, defining these “tokens” eases the complexity of creating and debugging the parse rules.
+
+####Testing
+
+There are two main types of tests that are used to QA parsers and rules. The first is known as a rules capture test. In this test the rule is exposed to everything that it is likely to encounter. The test passes if the rule captures everything it should capture and doesn’t capture anything else. In the former test, the parser is configured to send generated events to the test. The test the counts each of the different types of events. The test passes if the counts for each event type reach the expected value.
+
+There is a third test that has, unfortunately, not bee applied to all parsers as of yet. In this test, the parsers will parse a log fragment to produce a well known event. The test passes if all of the attributes of that event match the expected value.
+
+
+For historical reasons, SurvivorSpace is treated as a JVMEvent even though in reality, it’s an attribute of a young generational collection. This record is created by a parser that is specialized to parse the log and extract out the survivor information.
+
+### JVMEvent
+
+A JVMEvent represents something that happened in the JVM. The primary attributes are the type of event, the time of the event, and it’s duration. Each specialization of JVMEvent will contain attributes that are specific to that event. For example, a PSYoung represent a Parallel Young generational collection. In addition to the information above, it will have heap occupancy before and after the collection along with the size of heap before and after the collection. The event may contain more information depending upon the level of detailed information in the log file. As previously mentioned, any survivor space data will be ignored as that is dealt with in its own event.  A complete set of events can be seen in the diagram below. A complete discription of each event can be found in the corresponding JavaDoc.
+
+![GCToolkit Design](images/GCToolkit_Events.png)
+Figure 2. GCToolkit Event Hierarchy
+
+### Aggregator and Aggregation
+
+
+As can be seen in Figure 1, the end point for delivery of a JVMEvent as far as the framework is concerned, is an Aggregator. Aggregator classes must be provided by the users of GCToolkit as they are not provided as they are considered out of scope for this project. The role of the Aggregator is to capture the JVMEvent objects that are of interest to it and the extract the data of interest and pass it along to an Aggregation.
+
+As is the case with Aggregator, Aggregation classes must be supplied by users of GCToolkit. The role of an Aggregation is to collect the data and perform all calculations needed to transform the event data into a form that fits the needs of the client. For example, a GUI may want to display heap occupancy after collection. The Aggregator would capture all GC pause events from which contain reasonable accurate measures of this metrics. This information would be collected into an Aggregator.
+
+    It is the responsibility of GCToolkit to load and register all instances of Aggregation via the module’s SPI
+<todo: show sample code>
+
+### Committing
+
+One should tag a commit following the [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) guidelines.
+
+## License
+
+Microsoft GCToolKit is licensed under the [MIT](https://github.com/microsoft/gctoolkit/blob/master/LICENSE) license.
diff --git a/IT/src/test/java/com/microsoft/gctoolkit/integration/aggregation/RuntimeAggregationTest.java b/IT/src/test/java/com/microsoft/gctoolkit/integration/aggregation/RuntimeAggregationTest.java
deleted file mode 100644
index 103b389..0000000
--- a/IT/src/test/java/com/microsoft/gctoolkit/integration/aggregation/RuntimeAggregationTest.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package com.microsoft.gctoolkit.integration.aggregation;
-
-import com.microsoft.gctoolkit.sample.aggregation.RuntimeAggregation;
-
-public class RuntimeAggregationTest extends RuntimeAggregation {
-
-    @Override
-    public boolean hasWarning() {
-        return false;
-    }
-
-    @Override
-    public boolean isEmpty() {
-        return false;
-    }
-}
diff --git a/IT/src/test/java/com/microsoft/gctoolkit/integration/io/TestLogFile.java b/IT/src/test/java/com/microsoft/gctoolkit/integration/io/TestLogFile.java
deleted file mode 100644
index 2eec6ba..0000000
--- a/IT/src/test/java/com/microsoft/gctoolkit/integration/io/TestLogFile.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package com.microsoft.gctoolkit.integration.io;
-
-import java.io.File;
-import java.util.Arrays;
-
-public class TestLogFile {
-    private final File logFile;
-
-    private static final String[] relativePaths = {
-            "./",
-            "preunified/",
-            "preunified/cms/parnew/details/tenuring/",
-            "preunified/verbose/tenuring/",
-            "preunified/ps/details/tenuring/",
-            "preunified/ps/details/",
-            "unified/",
-            "streaming/",
-            "safepoint/",
-    };
-
-    public TestLogFile(String fileName) {
-        logFile = Arrays.stream(relativePaths)
-                .flatMap(path -> Arrays.stream(new String[]{
-                        "./" + path,
-                        "../" + path,
-                        "../../" + path,
-                        "./gclogs/" + path,
-                        "../gclogs/" + path,
-                        "../../gclogs/" + path,
-                }))
-                .map(path -> new File(path + File.separator + fileName))
-                .filter(File::exists)
-                .findFirst()
-                .orElseThrow(() -> new RuntimeException(fileName + " not found"));
-    }
-
-    public TestLogFile(File file) {
-        this.logFile = file;
-    }
-
-    public String getPath() {
-        return logFile.getPath();
-    }
-
-    public File getFile() {
-        return logFile;
-    }
-}
diff --git a/api/src/main/java/com/microsoft/gctoolkit/event/jvm/MetaspaceSummary.java b/api/src/main/java/com/microsoft/gctoolkit/event/jvm/MetaspaceSummary.java
index d8c9cdb..0727ac1 100644
--- a/api/src/main/java/com/microsoft/gctoolkit/event/jvm/MetaspaceSummary.java
+++ b/api/src/main/java/com/microsoft/gctoolkit/event/jvm/MetaspaceSummary.java
@@ -9,6 +9,10 @@ public class MetaspaceSummary extends MemoryPoolSummary {
     private final long reserved;
     private final long available;
 
+    public MetaspaceSummary(long before, long after, long committed, long reserved) {
+        this(before, after, -1L, committed, reserved);
+    }
+
     public MetaspaceSummary(long before, long after, long available, long committed, long reserved) {
         super(before, after, committed);
         this.reserved = reserved;
diff --git a/api/src/main/java/com/microsoft/gctoolkit/io/GCLogFileSegment.java b/api/src/main/java/com/microsoft/gctoolkit/io/GCLogFileSegment.java
index 6b0fe49..68afe4a 100644
--- a/api/src/main/java/com/microsoft/gctoolkit/io/GCLogFileSegment.java
+++ b/api/src/main/java/com/microsoft/gctoolkit/io/GCLogFileSegment.java
@@ -8,20 +8,47 @@ import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.time.ZonedDateTime;
 import java.util.ArrayList;
 import java.util.Comparator;
+import java.util.List;
 import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
 /**
  * A {@link RotatingGCLogFile} is made up of {@code GarbageCollectionLogFileSegment}s. Creating
  * a {@code GarbageCollectionLogFileSegment} is not necessary when the
  * {@link RotatingGCLogFile#RotatingGCLogFile(Path)} constructor is used.
- * The { @ link RotatingGCLogFile # RotatingGCLogFile(Path, List) } constructor allows the user to
+ * The {@link RotatingGCLogFile#RotatingGCLogFile(Path, List)} constructor allows the user to
  * provide a list of discrete {@code GarbageCollectionLogFileSegement}s for a {@code RotatingGCLogFile}.
  */
 public class GCLogFileSegment implements LogFileSegment {
 
+    private static final String ROTATING_LOG_SUFFIX = ".*\\.(\\d+)(\\.current)?$";
+    private static final Pattern ROTATING_LOG_PATTERN = Pattern.compile(ROTATING_LOG_SUFFIX);
+//
+//    // Generic tokens
+    private static final String DECIMAL_POINT = "(?:\\.|,)";
+    private static final String INTEGER = "\\d+";
+    private static final String DATE = "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}[\\+|\\-]\\d{4}";
+    private static final String TIME = INTEGER + DECIMAL_POINT + "\\d{3}";
+//
+//    // Pre-unified tokens
+    private static final String TIMESTAMP = "(" + TIME + "): ";
+    private static final String DATE_STAMP = "(" + DATE + "): ";
+    private static final String DATE_TIMESTAMP = "^(?:" + DATE_STAMP + ")?" + TIMESTAMP;
+//
+//    //  2017-09-07T09:00:12.795+0200: 0.716:
+    private static final Pattern PREUNIFIED_DATE_TIMESTAMP = Pattern.compile(DATE_TIMESTAMP);
+//
+//    // Unified Tokens
+    private static final String DATE_TAG = "\\[" + DATE + "\\]";
+    private static final String UPTIME_TAG = "\\[" + TIME + "s\\]";
+//
+//    // JEP 158 has ISO-8601 time and uptime in seconds and milliseconds as the first two decorators.
+    private static final Pattern UNIFIED_DATE_TIMESTAMP= Pattern.compile("^(" + DATE_TAG + ")?(" + UPTIME_TAG + ")?");
+
     private final Path path;
     private final int segmentIndex;
     private final boolean current;
@@ -56,56 +83,14 @@ public class GCLogFileSegment implements LogFileSegment {
         return path;
     }
 
-    public String getSegmentName() {
-        return getPath().toFile().getName();
-    }
-
-    /**
-     * return some comparable value for the first time found in the log.
-     * If isn't found, then return min value. This combined with the end
-     * time being a max value implies the log covers an impossible amount
-     * of time. The sorting logic in the Metadata classes should filter
-     * out these types of segments.
-     * @return double representing either the age of the JVM or time
-     * from epoch if only a date stamp is found at the beginning of the log file
-     */
     @Override
     public double getStartTime() {
-        try {
-            ageOfJVMAtLogStart();
-            if ( startTime.hasTimeStamp())
-                return startTime.getTimeStamp();
-            else if ( startTime.hasDateTime())
-                return startTime.toEpochInMillis();
-            else
-                return Double.MAX_VALUE;
-        } catch (NullPointerException ex) {
-            return Double.MAX_VALUE;
-        }
+        return 0;
     }
 
-    /**
-     * return some comparable value for the last time found in the log.
-     * If isn't found, then return max value. This combined with the start
-     * time implies the log covers an impossible amount of time. The
-     * sorting logic in the Metadata classes should filter out these
-     * types of segments.
-     * @return double representing either the age of the JVM or time
-     * from epoch if only a date stamp is found at the end of the log file
-     */
     @Override
     public double getEndTime() {
-        try {
-            ageOfJVMAtLogEnd();
-            if ( endTime.hasTimeStamp())
-                return endTime.getTimeStamp();
-            else if ( endTime.hasDateTime())
-                return endTime.toEpochInMillis();
-            else
-                return Double.MAX_VALUE;
-        } catch (NullPointerException|IOException ex) {
-            return Double.MIN_VALUE;
-        }
+        return 0;
     }
 
     /**
@@ -138,35 +123,137 @@ public class GCLogFileSegment implements LogFileSegment {
         return current;
     }
 
-    private DateTimeStamp ageOfJVMAtLogStart() {
-        if (startTime == null) {
-            startTime = stream()
-                    .map(DateTimeStamp::fromGCLogLine)
-                    .filter(dateTimeStamp -> dateTimeStamp.hasTimeStamp() || dateTimeStamp.hasDateStamp())
-                    .findFirst()
-                    .orElse(new DateTimeStamp(-1.0d));
-        }
+    private DateTimeStamp ageOfJVMAtLogStart() throws IOException {
+        if (startTime == null)
+            startTime = scanForTimeOfLogStart(path);
         return startTime;
     }
 
     private DateTimeStamp ageOfJVMAtLogEnd() throws IOException {
-        if (endTime == null) {
-            endTime = tail(100).stream()
-                    .map(DateTimeStamp::fromGCLogLine)
-                    .filter(dateTimeStamp -> dateTimeStamp.hasTimeStamp() || dateTimeStamp.hasDateStamp())
-                    .max(Comparator.comparing(dateTimeStamp -> dateTimeStamp != null ? dateTimeStamp.getTimeStamp() : 0))
-                    .orElse(new DateTimeStamp(-1.0d));
-        }
+        if (endTime == null)
+            endTime = scanForTimeOfLogEnd(path);
         return endTime;
     }
 
+    // Define the maximum time (in milliseconds) between two rotating logs for them to be considered contiguous.
+    private static final long MAX_INTERSITCE = Long.getLong("max-rotating-log-interstice", 30 * 1000);
+
+    // does this log begin after otherSegment ends
+    // log roll over has no JVM age.. can we estimate this...
+
+    /**
+     * Return true if this segment is a rollover from the other segment. If this segment starts
+     * after the other segment ends, and the time difference between them is small, the segments are
+     * considered contiguous.
+     * @param otherSegment The log file segment being compared to this.
+     * @return {@code true} if this segment is a rollover from the other segment.
+     */
+    public boolean isContiguousWith(GCLogFileSegment otherSegment) {
+        // Compare by calendar date, if possible.
+        double delta = rolloverDelta(this, otherSegment);
+        if (Double.isNaN(delta)) {
+            return false;
+        }
+        long intersticialDelta = (long)(delta * 1000d);
+        return (0 <= intersticialDelta) && (intersticialDelta < MAX_INTERSITCE);
+    }
+
+    // calculate the delta between the start of newSegment and the end of oldSegment.
+    /* package scope for testing */ static double rolloverDelta(GCLogFileSegment newSegment, GCLogFileSegment oldSegment) {
+        DateTimeStamp startAge;
+        DateTimeStamp endAge;
+        try {
+            startAge = newSegment.ageOfJVMAtLogStart();
+            endAge = oldSegment.ageOfJVMAtLogEnd();
+        } catch (IOException e) {
+            // TODO: no access to logger here...
+            return Double.NaN;
+        }
+
+        if (startAge == null || endAge == null) {
+            return Double.NaN;
+        }
+
+        // Compare by calendar date, not uptime, if possible.
+        double startTime;
+        double endTime;
+        if (startAge.hasDateStamp() && endAge.hasDateStamp()) {
+            ZonedDateTime startDate = startAge.getDateTime();
+            startTime = (double)startDate.toEpochSecond() + (double)startDate.getNano() / 1_000_000_000d;
+
+            ZonedDateTime endDate   = endAge.getDateTime();
+            endTime = (double)endDate.toEpochSecond() + (double)endDate.getNano() / 1_000_000_000d;
+
+        } else {
+            startTime = startAge.getTimeStamp();
+            endTime   = endAge.getTimeStamp();
+        }
+        return startTime - endTime;
+    }
+
     /**
      * {@inheritDoc}
-     * @return Returns {@code this.getName(); }
+     * @return Returns {@code this.getPath().toString(); }
      */
     @Override
     public String toString() {
-        return getSegmentName();
+        return path.toString();
+    }
+
+    private static Matcher matcher(String line) {
+        if (line.startsWith("[")) {
+            return UNIFIED_DATE_TIMESTAMP.matcher(line);
+        } else {
+            return PREUNIFIED_DATE_TIMESTAMP.matcher(line);
+        }
+    }
+
+    private static DateTimeStamp calculateDateTimeStamp(Matcher matcher) {
+        if (matcher.pattern() == UNIFIED_DATE_TIMESTAMP) {
+            return calclateUnifiedDateTimeStamp(matcher);
+        } else {
+            return calculatePreUnifiedDateTimeStamp(matcher);
+        }
+    }
+
+    // [2020-04-30T12:01:11.231-0400][2020-04-30T16:01:11.231+0000][0.009s][1588262471231ms][9ms][270937237146899ns][93577ns]
+    private static DateTimeStamp calclateUnifiedDateTimeStamp(Matcher matcher) {
+        String t = matcher.group(1);
+        String time = t != null ? t.substring(1, t.length()-1) : null;
+        String u = matcher.group(2);
+        double uptime = u != null ? parseDouble(u.substring(1, u.length()-2)) : -1.0d;
+        return new DateTimeStamp(time, uptime);
+    }
+
+    // 2017-09-07T09:00:12.795+0200: 0.716
+    // group(1) = 2017-09-07T09:00:12.795+0200, group(2) = 0, group(3) = 716
+    private static DateTimeStamp calculatePreUnifiedDateTimeStamp(Matcher matcher) {
+        String dateStamp = matcher.group(1);
+        double timeStamp = matcher.group(2) != null ? parseDouble(matcher.group(2)) : -1.0d;
+        return new DateTimeStamp(dateStamp, timeStamp);
+    }
+
+    private static double parseDouble(String string) {
+        if (string == null) return Double.NaN;
+        return Double.parseDouble(string.replace(',','.'));
+    }
+
+    private static DateTimeStamp scanForTimeOfLogStart(Path path) throws IOException {
+        return Files.lines(path)
+                .map(GCLogFileSegment::matcher)
+                .filter(Matcher::find)
+                .findFirst()
+                .map(GCLogFileSegment::calculateDateTimeStamp)
+                .orElse(null);
+    }
+
+    private static DateTimeStamp scanForTimeOfLogEnd(Path path) throws IOException {
+        return tail(path,100).stream()
+                .map(GCLogFileSegment::matcher)
+                .filter(Matcher::find)
+                .map(GCLogFileSegment::calculateDateTimeStamp)
+                .max(Comparator.comparing(dateTimeStamp -> dateTimeStamp != null ? dateTimeStamp.getTimeStamp() : 0))
+                .orElse(null);
     }
 
 
@@ -174,7 +261,7 @@ public class GCLogFileSegment implements LogFileSegment {
      // https://codereview.stackexchange.com/questions/79039/get-the-tail-of-a-file-the-last-10-lines
      // Tail is not a class, it's a method so the solution in stackoverflow isn't correct but the core
      // could be used here as it's cleaner
-    private ArrayList<String> tail(int numberOfLines) throws IOException {
+    private static ArrayList<String> tail(Path path, int numberOfLines) throws IOException {
 
         char LF = '\n';
         char CR = '\r';
diff --git a/api/src/main/java/com/microsoft/gctoolkit/io/GCLogFileZipSegment.java b/api/src/main/java/com/microsoft/gctoolkit/io/GCLogFileZipSegment.java
index da90fd2..80225d6 100644
--- a/api/src/main/java/com/microsoft/gctoolkit/io/GCLogFileZipSegment.java
+++ b/api/src/main/java/com/microsoft/gctoolkit/io/GCLogFileZipSegment.java
@@ -4,31 +4,55 @@ package com.microsoft.gctoolkit.io;
 
 import com.microsoft.gctoolkit.time.DateTimeStamp;
 
-import java.io.BufferedReader;
 import java.io.IOException;
-import java.io.InputStreamReader;
+import java.io.RandomAccessFile;
+import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayDeque;
+import java.time.ZonedDateTime;
 import java.util.ArrayList;
 import java.util.Comparator;
-import java.util.Deque;
 import java.util.List;
-import java.util.stream.Collector;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import java.util.stream.Stream;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
 
 /**
  * A {@link RotatingGCLogFile} is made up of {@code GarbageCollectionLogFileSegment}s. Creating
  * a {@code GarbageCollectionLogFileSegment} is not necessary when the
  * {@link RotatingGCLogFile#RotatingGCLogFile(Path)} constructor is used.
- * The {@link RotatingGCLogFile#RotatingGCLogFile(Path)} constructor allows the user to
+ * The {@link RotatingGCLogFile#RotatingGCLogFile(Path, List)} constructor allows the user to
  * provide a list of discrete {@code GarbageCollectionLogFileSegement}s for a {@code RotatingGCLogFile}.
  */
 public class GCLogFileZipSegment implements LogFileSegment {
 
+    private static final String ROTATING_LOG_SUFFIX = ".*\\.(\\d+)(\\.current)?$";
+    private static final Pattern ROTATING_LOG_PATTERN = Pattern.compile(ROTATING_LOG_SUFFIX);
+
+    // Generic tokens
+    private static final String DECIMAL_POINT = "(?:\\.|,)";
+    private static final String INTEGER = "\\d+";
+    private static final String DATE = "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}[\\+|\\-]\\d{4}";
+    private static final String TIME = INTEGER + DECIMAL_POINT + "\\d{3}";
+
+    // Pre-unified tokens
+    private static final String TIMESTAMP = "(" + TIME + "): ";
+    private static final String DATE_STAMP = "(" + DATE + "): ";
+    private static final String DATE_TIMESTAMP = "^(?:" + DATE_STAMP + ")?" + TIMESTAMP;
+
+    //  2017-09-07T09:00:12.795+0200: 0.716:
+    private static final Pattern PREUNIFIED_DATE_TIMESTAMP = Pattern.compile(DATE_TIMESTAMP);
+
+    // Unified Tokens
+    private static final String DATE_TAG = "\\[" + DATE + "\\]";
+    private static final String UPTIME_TAG = "\\[" + TIME + "s\\]";
+
+    // JEP 158 has ISO-8601 time and uptime in seconds and milliseconds as the first two decorators.
+    private static final Pattern UNIFIED_DATE_TIMESTAMP= Pattern.compile("^(" + DATE_TAG + ")?(" + UPTIME_TAG + ")?");
+
     private final Path path;
     private final String segmentName;
+    //private final int segmentIndex;
+    //private final boolean current;
     private DateTimeStamp endTime = null;
     private DateTimeStamp startTime = null;
 
@@ -40,6 +64,17 @@ public class GCLogFileZipSegment implements LogFileSegment {
     public GCLogFileZipSegment(Path path, String segmentName) {
         this.path = path;
         this.segmentName = segmentName;
+
+//        String filename = path.getFileName().toString();
+//        Matcher matcher = ROTATING_LOG_PATTERN.matcher(filename);
+//        if (matcher.matches()) {
+//            segmentIndex = Integer.parseInt(matcher.group(1));
+//            current = ".current".equals(matcher.group(2));
+//        } else {
+//            // unified log with no number is the current file
+//            segmentIndex = Integer.MAX_VALUE;
+//            current = true;
+//        }
     }
 
     /**
@@ -50,76 +85,16 @@ public class GCLogFileZipSegment implements LogFileSegment {
         return path;
     }
 
-    public String getSegmentName() {
-        return this.segmentName;
-    }
-
-    private DateTimeStamp ageOfJVMAtLogStart() {
-        if (startTime == null) {
-            startTime = stream()
-                    .map(DateTimeStamp::fromGCLogLine)
-                    .filter(dateTimeStamp -> dateTimeStamp.hasTimeStamp() || dateTimeStamp.hasDateStamp())
-                    .findFirst()
-                    .orElse(new DateTimeStamp(-1.0d));
-        }
-        return startTime;
-    }
-
-    private DateTimeStamp ageOfJVMAtLogEnd()  {
-        if (endTime == null) {
-            List<String> tail = stream().
-                    collect(tail(100));
-            endTime = tail.stream()
-                    .filter(line -> ! line.contains("Saved as"))
-                    .map(DateTimeStamp::fromGCLogLine)
-                    .filter(dateTimeStamp -> dateTimeStamp.hasTimeStamp() || dateTimeStamp.hasDateStamp())
-                    .max(Comparator.comparing(dateTimeStamp -> dateTimeStamp != null ? dateTimeStamp.getTimeStamp() : 0))
-                    .orElse(new DateTimeStamp(-1.0d));
-        }
-        return endTime;
-    }
-
-    public <T> Collector<T, ?, List<T>> tail(int n) {
-        return Collector.<T, Deque<T>, List<T>>of(ArrayDeque::new, (buffer, line) -> {
-            if(buffer.size() == n)
-                buffer.pollFirst();
-            buffer.add(line);
-        }, (buffer, list) -> {
-            while(list.size() < n && !buffer.isEmpty()) {
-                list.addFirst(buffer.pollLast());
-            }
-            return list;
-        }, ArrayList::new);
-    }
+    public String getSegmentName() { return this.segmentName; }
 
     @Override
     public double getStartTime() {
-        try {
-            ageOfJVMAtLogStart();
-            if ( startTime.hasTimeStamp())
-                return startTime.getTimeStamp();
-            else if ( startTime.hasDateTime())
-                return startTime.toEpochInMillis();
-            else
-                return Double.MAX_VALUE;
-        } catch (NullPointerException ex) {
-            return Double.MIN_VALUE;
-        }
+        return 0;
     }
 
     @Override
     public double getEndTime() {
-        try {
-            ageOfJVMAtLogEnd();
-            if ( endTime.hasTimeStamp())
-                return endTime.getTimeStamp();
-            else if ( endTime.hasDateTime())
-                return endTime.toEpochInMillis();
-            else
-                return Double.MAX_VALUE;
-        } catch (NullPointerException ex) {
-            return Double.MIN_VALUE;
-        }
+        return 0;
     }
 
     /**
@@ -127,22 +102,132 @@ public class GCLogFileZipSegment implements LogFileSegment {
      * @return A stream of lines from the file.
      */
     public Stream<String> stream() {
-        try {
-            ZipFile file = new ZipFile(path.toFile());
-            ZipEntry entry = file.getEntry(this.segmentName);
-            return new BufferedReader(new InputStreamReader(file.getInputStream(entry))).lines();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-        return new ArrayList<String>().stream();
+//        try {
+//            return Files.lines(path);
+//        } catch (IOException e) {
+//            e.printStackTrace();
+//        }
+        return null;
     }
 
+    // Define the maximum time (in milliseconds) between two rotating logs for them to be considered contiguous.
+    //private static final long MAX_INTERSITCE = Long.getLong("max-rotating-log-interstice", 30 * 1000);
+
+    // does this log begin after otherSegment ends
+    // log roll over has no JVM age.. can we estimate this...
+
+    /**
+     * Return true if this segment is a rollover from the other segment. If this segment starts
+     * after the other segment ends, and the time difference between them is small, the segments are
+     * considered contiguous.
+     * @param otherSegment The log file segment being compared to this.
+     * @return {@code true} if this segment is a rollover from the other segment.
+     */
+//    public boolean isContiguousWith(GCLogFileZipSegment otherSegment) {
+//        // Compare by calendar date, if possible.
+//        double delta = rolloverDelta(this, otherSegment);
+//        if (Double.isNaN(delta)) {
+//            return false;
+//        }
+//        long intersticialDelta = (long)(delta * 1000d);
+//        return (0 <= intersticialDelta) && (intersticialDelta < MAX_INTERSITCE);
+//    }
+
+    // calculate the delta between the start of newSegment and the end of oldSegment.
+//    /* package scope for testing */ static double rolloverDelta(GCLogFileZipSegment newSegment, GCLogFileZipSegment oldSegment) {
+//        DateTimeStamp startAge;
+//        DateTimeStamp endAge;
+//        try {
+//            startAge = newSegment.ageOfJVMAtLogStart();
+//            endAge = oldSegment.ageOfJVMAtLogEnd();
+//        } catch (IOException e) {
+//            // TODO: no access to logger here...
+//            return Double.NaN;
+//        }
+//
+//        if (startAge == null || endAge == null) {
+//            return Double.NaN;
+//        }
+//
+//        // Compare by calendar date, not uptime, if possible.
+//        double startTime;
+//        double endTime;
+//        if (startAge.hasDateStamp() && endAge.hasDateStamp()) {
+//            ZonedDateTime startDate = startAge.getDateTime();
+//            startTime = (double)startDate.toEpochSecond() + (double)startDate.getNano() / 1_000_000_000d;
+//
+//            ZonedDateTime endDate   = endAge.getDateTime();
+//            endTime = (double)endDate.toEpochSecond() + (double)endDate.getNano() / 1_000_000_000d;
+//
+//        } else {
+//            startTime = startAge.getTimeStamp();
+//            endTime   = endAge.getTimeStamp();
+//        }
+//        return startTime - endTime;
+//    }
+
     /**
      * {@inheritDoc}
      * @return Returns {@code this.getPath().toString(); }
      */
-    @Override
-    public String toString() {
-        return getSegmentName();
-    }
+//    @Override
+//    public String toString() {
+//        return path.toString();
+//    }
+//
+//    private static Matcher matcher(String line) {
+//        if (line.startsWith("[")) {
+//            return UNIFIED_DATE_TIMESTAMP.matcher(line);
+//        } else {
+//            return PREUNIFIED_DATE_TIMESTAMP.matcher(line);
+//        }
+//    }
+
+//    private static DateTimeStamp calculateDateTimeStamp(Matcher matcher) {
+//        if (matcher.pattern() == UNIFIED_DATE_TIMESTAMP) {
+//            return calclateUnifiedDateTimeStamp(matcher);
+//        } else {
+//            return calculatePreUnifiedDateTimeStamp(matcher);
+//        }
+//    }
+
+    // [2020-04-30T12:01:11.231-0400][2020-04-30T16:01:11.231+0000][0.009s][1588262471231ms][9ms][270937237146899ns][93577ns]
+//    private static DateTimeStamp calclateUnifiedDateTimeStamp(Matcher matcher) {
+//        String t = matcher.group(1);
+//        String time = t != null ? t.substring(1, t.length()-1) : null;
+//        String u = matcher.group(2);
+//        double uptime = u != null ? parseDouble(u.substring(1, u.length()-2)) : -1.0d;
+//        return new DateTimeStamp(time, uptime);
+//    }
+
+    // 2017-09-07T09:00:12.795+0200: 0.716
+    // group(1) = 2017-09-07T09:00:12.795+0200, group(2) = 0, group(3) = 716
+//    private static DateTimeStamp calculatePreUnifiedDateTimeStamp(Matcher matcher) {
+//        String dateStamp = matcher.group(1);
+//        double timeStamp = matcher.group(2) != null ? parseDouble(matcher.group(2)) : -1.0d;
+//        return new DateTimeStamp(dateStamp, timeStamp);
+//    }
+
+//    private static double parseDouble(String string) {
+//        if (string == null) return Double.NaN;
+//        return Double.parseDouble(string.replace(',','.'));
+//    }
+//
+//    private static DateTimeStamp scanForTimeOfLogStart(Path path) throws IOException {
+//        return Files.lines(path)
+//                .map(GCLogFileZipSegment::matcher)
+//                .filter(Matcher::find)
+//                .findFirst()
+//                .map(GCLogFileZipSegment::calculateDateTimeStamp)
+//                .orElse(null);
+//    }
+
+//    private static DateTimeStamp scanForTimeOfLogEnd(Path path) throws IOException {
+//        return tail(path,100).stream()
+//                .map(GCLogFileZipSegment::matcher)
+//                .filter(Matcher::find)
+//                .map(GCLogFileZipSegment::calculateDateTimeStamp)
+//                .max(Comparator.comparing(dateTimeStamp -> dateTimeStamp != null ? dateTimeStamp.getTimeStamp() : 0))
+//                .orElse(null);
+//    }
 }
diff --git a/api/src/main/java/com/microsoft/gctoolkit/io/LogFileMetadata.java b/api/src/main/java/com/microsoft/gctoolkit/io/LogFileMetadata.java
index 97c4bba..81bff8f 100644
--- a/api/src/main/java/com/microsoft/gctoolkit/io/LogFileMetadata.java
+++ b/api/src/main/java/com/microsoft/gctoolkit/io/LogFileMetadata.java
@@ -4,9 +4,13 @@ package com.microsoft.gctoolkit.io;
 
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.nio.file.Files;
 import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.logging.Logger;
 import java.util.stream.Stream;
+import java.util.zip.ZipFile;
 
 /**
  * Meta-data about a {@link FileDataSource}.
diff --git a/api/src/main/java/com/microsoft/gctoolkit/io/LogFileSegment.java b/api/src/main/java/com/microsoft/gctoolkit/io/LogFileSegment.java
index 53e103a..a7149ca 100644
--- a/api/src/main/java/com/microsoft/gctoolkit/io/LogFileSegment.java
+++ b/api/src/main/java/com/microsoft/gctoolkit/io/LogFileSegment.java
@@ -1,16 +1,11 @@
 package com.microsoft.gctoolkit.io;
 
 import java.nio.file.Path;
-import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
 public interface LogFileSegment {
 
-    String ROTATING_LOG_SUFFIX = ".*\\.(\\d+)(\\.current)?$";
-    Pattern ROTATING_LOG_PATTERN = Pattern.compile(ROTATING_LOG_SUFFIX);
-
     Path getPath();
-    String getSegmentName();
     double getStartTime();
     double getEndTime();
     Stream<String> stream();
diff --git a/api/src/main/java/com/microsoft/gctoolkit/io/RotatingGCLogFile.java b/api/src/main/java/com/microsoft/gctoolkit/io/RotatingGCLogFile.java
index 64e1ddd..4d8fa07 100644
--- a/api/src/main/java/com/microsoft/gctoolkit/io/RotatingGCLogFile.java
+++ b/api/src/main/java/com/microsoft/gctoolkit/io/RotatingGCLogFile.java
@@ -8,14 +8,21 @@ import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.SequenceInputStream;
 import java.io.UncheckedIOException;
+import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
+import java.nio.file.Paths;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Objects;
 import java.util.Vector;
+import java.util.function.Predicate;
+import java.util.logging.Level;
 import java.util.logging.Logger;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.zip.ZipEntry;
@@ -36,8 +43,45 @@ public class RotatingGCLogFile extends GCLogFile {
      */
     public RotatingGCLogFile(Path path) {
         super(path);
+
+//        if (getMetaData().isZip() || getMetaData().isGZip()) {
+//            //TODO: add code to ensure correct order to stream files in zip and gzip files
+//            this.orderedGarbageCollectionLogFiles = new LinkedList<>();
+//        } else {
+//            LinkedList<GCLogFileSegment> orderedSegments = null;
+//            try {
+//                List<GCLogFileSegment> segments = findGCLogSegments();
+//                orderedSegments = orderSegments(segments);
+//            } catch (IOException e) {
+//                LOGGER.log(Level.WARNING, "Cannot find and order GC log file segments for: " + path);
+//            } finally {
+//                this.orderedGarbageCollectionLogFiles = orderedSegments;
+//            }
+//        }
+    }
+
+    /**
+     * Create a RotatingGCLogFile with the given log file segments.
+     * @param parentDirectory The directory that contains the log file segments.
+     */
+    public RotatingGCLogFile(Path parentDirectory, List<GCLogFileSegment> segments) throws IOException {
+        super(parentDirectory); //, new SingleLogFileMetadata(parentDirectory));
+        //this.orderedGarbageCollectionLogFiles = orderSegments(segments);
     }
 
+    /**
+     * A regular expression for matching a file name suffix such as '.0' or '.5.current'
+     */
+    private static final String ROTATING_LOG_SUFFIX = ".*(\\.\\d+(?:\\.current)?)$";
+
+    /**
+     * A pattern for matching the suffix of a rotating log file, such as '.0' or '.5.current'. Given
+     * Path.getFileName().toString(), group(1) is the suffix of the rotating log. The dot is not
+     * captured in the first group.
+     */
+    public static final Pattern ROTATING_LOG_PATTERN = Pattern.compile(ROTATING_LOG_SUFFIX);
+
+    //private final LinkedList<GCLogFileSegment> orderedGarbageCollectionLogFiles;
     private RotatingLogFileMetadata metaData;
 
     public LogFileMetadata getMetaData() throws IOException {
@@ -48,13 +92,14 @@ public class RotatingGCLogFile extends GCLogFile {
 
     @Override
     public Stream<String> stream() throws IOException {
-        if ( getMetaData().isDirectory() || getMetaData().isPlainText() || getMetaData().isZip())
-            return getMetaData().logFiles().flatMap(segment -> segment.stream());
-        else // yes, this is returning an empty stream.
-            return new ArrayList<String>().stream();
+        //return metaData.logFiles().flatMap(LogFileSegment::stream);x
+        return stream(getMetaData(), null); // orderedGarbageCollectionLogFiles);
     }
 
-    private Stream<String> stream(LogFileMetadata metadata, LinkedList<GCLogFileSegment> segments) throws IOException {
+    private Stream<String> stream(
+            LogFileMetadata metadata,
+            LinkedList<GCLogFileSegment> segments)
+            throws IOException {
         //todo: find rolling files....
         if (metadata.isPlainText() || metadata.isDirectory()) {
             switch (segments.size()) {
@@ -112,7 +157,108 @@ public class RotatingGCLogFile extends GCLogFile {
      * the files that match the rotating pattern.
      * @return The log file segments in rotating order.
      */
-    public List<LogFileSegment> getOrderedGarbageCollectionLogFiles() throws IOException {
-        return getMetaData().logFiles().collect(Collectors.toList());
+    public List<GCLogFileSegment> getOrderedGarbageCollectionLogFiles() {
+        return null; //Collections.unmodifiableList(orderedGarbageCollectionLogFiles);
+    }
+
+    //assume directory but then allow for a file.
+    private List<GCLogFileSegment> findGCLogSegments() throws IOException {
+
+        if (Files.isRegularFile(path)) {
+            String filename = path.getFileName().toString();
+            Matcher matcher = ROTATING_LOG_PATTERN.matcher(filename);
+            String rotatingLogBaseName;
+            if (matcher.matches()) {
+                String suffix = matcher.group(1);
+                rotatingLogBaseName = filename.substring(0, filename.length()-suffix.length());
+            } else {
+                rotatingLogBaseName = filename;
+            }
+            Pattern rotatingLogBaseNamePattern = Pattern.compile(rotatingLogBaseName + "(?:" + ROTATING_LOG_SUFFIX + ")?");
+            Predicate<Path> gcLogFragmentFinder = file -> rotatingLogBaseNamePattern.matcher(file.getFileName().toString()).matches();
+            return Files.list(Paths.get(path.getParent().toString())).
+                    filter(Files::isRegularFile).
+                    filter(file -> !file.toFile().isHidden()).
+                    filter(gcLogFragmentFinder).
+                    map(GCLogFileSegment::new).
+                    collect(Collectors.toList());
+         } else if (Files.isDirectory(path)) {
+            return Files.list(path).
+                    filter(Files::isRegularFile).
+                    filter(file -> !file.toFile().isHidden()).
+                    map(GCLogFileSegment::new).
+                    collect(Collectors.toList());
+        }
+
+        throw new IllegalArgumentException("path is not a file or directory: " + path);
+    }
+
+    private LinkedList<GCLogFileSegment> orderSegments(List<GCLogFileSegment> gcLogSegments) {
+
+        // Unified rotation: jdk11/src/hotspot/share/logging/logFileOutput.cpp
+        //     Output is always to named file, e.g. 'gc.log' if given -Xlog:gc*:file=gc.log::filecount=5
+        //     When gc.log is full, archive as gc.log.<_current_file>. Before the of gc.log to gc.log.<_current_file>,
+        //     an attempt is made to delete an existing gc.log.<_current_file>
+        //     Increment _current_file. if _current_file == filecount, set _current_file to zero
+        //         - JVM always begins archiving at gc.log.0
+        //         - gc.log is always the current log
+        //         - Once filecount files have been archived, archive begins at zero again
+        //
+        // Pre-unified rotation: jdk8/hotspot/src/share/vm/utilities/ostream.cpp
+        //     rotate file in names extended_filename.0, extended_filename.1, ...,
+        //     extended_filename.<NumberOfGCLogFiles - 1>. Current rotation file name will
+        //     have a form of extended_filename.<i>.current where i is the current rotation
+        //     file number. After it reaches max file size, the file will be saved and renamed
+        //     with .current removed from its tail.
+
+        if (gcLogSegments.size() < 2) {
+            return new LinkedList<>(gcLogSegments);
+        }
+
+        LinkedList<GCLogFileSegment> segments = new LinkedList<>();
+        GCLogFileSegment[] orderedSegments = gcLogSegments.toArray(new GCLogFileSegment[0]);
+        Arrays.sort(orderedSegments, Comparator.comparingInt(GCLogFileSegment::getSegmentIndex));
+
+        int current = orderedSegments.length;
+        while (0 <= --current) {
+            if (orderedSegments[current].isCurrent()) {
+                break;
+            }
+        }
+
+        // if current == -1, then there is no current! What to do?
+        if (current == -1) {
+            Collections.addAll(segments, orderedSegments);
+            return segments;
+        }
+
+        double closestTime = Double.MAX_VALUE;
+        // Find where current belongs.
+        for (int index = current-1; 0 <= index; --index) {
+            double delta = GCLogFileSegment.rolloverDelta(orderedSegments[current], orderedSegments[index]);
+            if (!Double.isNaN(delta) && 0 <= delta && delta < closestTime) {
+                GCLogFileSegment temp = orderedSegments[current];
+                for(int n=current; n > index+1; --n) {
+                    orderedSegments[n] = orderedSegments[n-1];
+                }
+                orderedSegments[current=index+1] = temp;
+                closestTime = delta;
+            }
+        }
+
+        segments.addLast(orderedSegments[current]);
+
+        int index = ((current-1) + orderedSegments.length) % orderedSegments.length;
+        while (index != current) {
+            if (orderedSegments[current].isContiguousWith(orderedSegments[index])) {
+                segments.addFirst(orderedSegments[index]);
+                current = index;
+                index = ((current - 1) + orderedSegments.length) % orderedSegments.length;
+            } else {
+                break;
+            }
+        }
+
+        return segments;
     }
 }
diff --git a/api/src/main/java/com/microsoft/gctoolkit/io/RotatingLogFileMetadata.java b/api/src/main/java/com/microsoft/gctoolkit/io/RotatingLogFileMetadata.java
index 3c0e5fa..5969c1c 100644
--- a/api/src/main/java/com/microsoft/gctoolkit/io/RotatingLogFileMetadata.java
+++ b/api/src/main/java/com/microsoft/gctoolkit/io/RotatingLogFileMetadata.java
@@ -2,13 +2,16 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.io;
 
+import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.Comparator;
-import java.util.LinkedList;
 import java.util.List;
+import java.util.function.Function;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.stream.Stream;
@@ -25,36 +28,27 @@ public class RotatingLogFileMetadata extends LogFileMetadata {
     private static final Logger LOG = Logger.getLogger(RotatingLogFileMetadata.class.getName());
 
     private List<LogFileSegment> segments;
+    private Function<LogFileSegment, Path> function = logFileSegment -> logFileSegment.getPath();
 
     public RotatingLogFileMetadata(Path path) throws IOException {
         super(path);
     }
 
     public Stream<LogFileSegment> logFiles() {
-        if ( segments == null) {
-            if ( isPlainText() || isDirectory())
-                findSegments();
-            else if ( isZip())
-                findZIPSegments();
-            else {
-                LOG.warning("unknown log file format");
-                segments = new ArrayList<>();
-            }
-        }
         return segments.stream();
     }
 
     private void findZIPSegments() {
         try (var zipfile = new ZipFile(getPath().toFile())) {
+            Function<ZipEntry,String> mapToName = zipEntry -> zipEntry.getName();
             segments = zipfile.stream()
                     .filter(zipEntry -> !zipEntry.isDirectory())
-                    .map(ZipEntry::getName)
+                    .map(mapToName)
                     .map(name -> new GCLogFileZipSegment(getPath(),name))
                     .collect(toList());
         } catch (IOException ioe) {
             LOG.warning(ioe.getMessage());
         }
-        orderSegments();
     }
 
     /**
@@ -71,62 +65,21 @@ public class RotatingLogFileMetadata extends LogFileMetadata {
             return this.segments.size();
     }
 
-    /**
-     * Root for the pattern for the file currently being written to... has
-     * a .<number> suffix for unified
-     * a .current suffix for pre-unified.
-     *
-     * The possible parameters here along with the actions
-     * 1) directory
-     * 2) the file currently being written to
-     * 3) a file not currently being written to.
-     *
-     * In all cases we want to find the file currently being written to and
-     * use that to reverse engineer the root.
-     *
-     * @return String representing the pattern for the root of the rotating log name
-     */
-    private String getRootPattern() {
-
-        // at this point we only have the path, not a segment... it maybe that we have to save the chosen segment
-        // so  that we can normalize the code path for zip and file based logs????
-        String[] bits;
-        if (isDirectory()) {
-            bits = segments.stream()
-                    .filter(segment -> !segment.getSegmentName().matches(".+\\.\\d+$"))
-                    .findFirst()
-                    .get()
-                    .getSegmentName().split("\\.");
-        } else if ( isZip()) {
-            bits = segments.get(0).getSegmentName().split("\\.");
-        } else {
-            bits = getPath().getFileName().toString().split("\\.");
-        }
-
-        int baseLength = 0;
-        if ( "current".equals(bits[bits.length - 1]))
-            baseLength = bits.length - 2;
-        else if ( bits[bits.length - 1].matches("\\d+$"))
-            baseLength = bits.length - 1;
-        else
-            baseLength = bits.length;
-
-        StringBuilder base = new StringBuilder(bits[0]);
-        for ( int i = 1; i < baseLength; i++)
-            base.append(".").append(bits[i]);
-        return base.toString();
-    }
-
-    private void findSegments() {
-        segments = new ArrayList<>();
+    public void findSegments() {
         try {
-            if (isDirectory()) {
-                Files.list(getPath()).map(GCLogFileSegment::new).forEach(segments::add);
-            }
-            else {
-                Files.list(getPath().getParent())
-                        .filter(file -> file.getFileName().toString().startsWith(getRootPattern()))
-                        .map(p -> new GCLogFileSegment(p)).forEach(segments::add);
+            segments = new ArrayList<>();
+            if (getPath().toFile().isDirectory()) {
+                Files.list(getPath()).map(entry -> new GCLogFileSegment(entry)).forEach(segments::add);
+            } else {
+                String[] bits = getPath().getFileName().toString().split("\\.");
+                StringBuilder pattern = new StringBuilder(bits[0]).append(".");
+                if (bits[bits.length - 1].matches("\\d+")) {
+                    for (int i = 1; i < bits.length - 1; i++)
+                        pattern.append(bits[i]).append(".");
+                    pattern.deleteCharAt(pattern.length() - 1);
+                }
+                String base = pattern.toString();
+                Files.list(getPath().getParent()).filter(file -> file.getFileName().toString().startsWith(base)).map(p -> new GCLogFileSegment(p)).forEach(segments::add);
             }
         } catch (IOException ioe) {
             LOG.log(Level.WARNING,"Unable to find log segments.", ioe);
@@ -134,38 +87,57 @@ public class RotatingLogFileMetadata extends LogFileMetadata {
         orderSegments();
     }
 
-    private void orderSegments() {
+    private List<LogFileSegment> orderSegments() {
+        // Unified rotation: jdk11/src/hotspot/share/logging/logFileOutput.cpp
+        //     Output is always to named file, e.g. 'gc.log' if given -Xlog:gc*:file=gc.log::filecount=5
+        //     When gc.log is full, archive as gc.log.<_current_file>. Before the of gc.log to gc.log.<_current_file>,
+        //     an attempt is made to delete an existing gc.log.<_current_file>
+        //     Increment _current_file. if _current_file == filecount, set _current_file to zero
+        //         - JVM always begins archiving at gc.log.0
+        //         - gc.log is always the current log
+        //         - Once filecount files have been archived, archive begins at zero again
+        //
+        // Pre-unified rotation: jdk8/hotspot/src/share/vm/utilities/ostream.cpp
+        //     rotate file in names extended_filename.0, extended_filename.1, ...,
+        //     extended_filename.<NumberOfGCLogFiles - 1>. Current rotation file name will
+        //     have a form of extended_filename.<i>.current where i is the current rotation
+        //     file number. After it reaches max file size, the file will be saved and renamed
+        //     with .current removed from its tail.
 
         if (segments.size() < 2) {
-            return;
+            return segments;
         }
 
-        LinkedList<LogFileSegment> orderedList = new LinkedList<>();
-        List<LogFileSegment> workingList = new ArrayList<>();
-        workingList.addAll(segments);
-
-        // Find current
-        String basePattern = getRootPattern();
-        LogFileSegment current = workingList.stream()
-                .filter( segment -> segment.getSegmentName().endsWith(basePattern) || segment.getSegmentName().endsWith(".current"))
-                .findFirst().get();
-
-        orderedList.addFirst(current);
-        workingList = removeIneligibleSegments (workingList, current);
-        while ( ! workingList.isEmpty()) {
-            current = workingList.stream()
-                    .max(Comparator.comparing(LogFileSegment::getEndTime))
-                    .get();
-            orderedList.addFirst(current);
-            workingList = removeIneligibleSegments (workingList, current);
+        //LinkedList<GarbageCollectionLogFileSegment> orderedSeqments = new LinkedList<>();
+        GCLogFileSegment[] workingList = segments.toArray(new GCLogFileSegment[0]);
+        Arrays.sort(workingList, Comparator.comparingInt(GCLogFileSegment::getSegmentIndex));
+
+        int current = workingList.length;
+        while (0 <= --current) {
+            if (workingList[current].isCurrent()) {
+                break;
+            }
         }
 
-        segments = orderedList;
-    }
+        // if current == -1, then there is no current! What to do?
+        if (current == -1) {
+            Collections.addAll(segments, workingList);
+            return segments;
+        }
 
-    private List<LogFileSegment> removeIneligibleSegments(final List<LogFileSegment> logFileSegments, final LogFileSegment current) {
-        return logFileSegments.stream()
-                .filter( segment -> segment.getEndTime() <= current.getStartTime())
-                .collect(toList());
+        double closestTime = Double.MAX_VALUE;
+        // Find where current belongs.
+        for (int index = current - 1; 0 <= index; --index) {
+            double delta = GCLogFileSegment.rolloverDelta(workingList[current], workingList[index]);
+            if (!Double.isNaN(delta) && 0 <= delta && delta < closestTime) {
+                GCLogFileSegment temp = workingList[current];
+                for (int n = current; n > index + 1; --n) {
+                    workingList[n] = workingList[n - 1];
+                }
+                workingList[current = index + 1] = temp;
+                closestTime = delta;
+            }
+        }
+        return null;
     }
 }
diff --git a/api/src/main/java/com/microsoft/gctoolkit/io/SingleGCLogFile.java b/api/src/main/java/com/microsoft/gctoolkit/io/SingleGCLogFile.java
index 7032c8e..25f33e9 100644
--- a/api/src/main/java/com/microsoft/gctoolkit/io/SingleGCLogFile.java
+++ b/api/src/main/java/com/microsoft/gctoolkit/io/SingleGCLogFile.java
@@ -43,16 +43,16 @@ public class SingleGCLogFile extends GCLogFile {
 
     @Override
     public Stream<String> stream() throws IOException {
-        return stream(getMetaData());
+        return stream(path, getMetaData());
     }
 
-    private Stream<String> stream(LogFileMetadata metadata) throws IOException {
+    private Stream<String> stream(Path path, LogFileMetadata metadata) throws IOException {
         if (metadata.isPlainText()) {
-            return Files.lines(metadata.getPath());
+            return Files.lines(path);
         } else if (metadata.isZip()) {
-            return streamZipFile(metadata.getPath());
+            return streamZipFile(path);
         } else if (metadata.isGZip()) {
-            return streamGZipFile(metadata.getPath());
+            return streamGZipFile(path);
         }
         throw new IOException("Unable to read " + path.toString());
     }
diff --git a/api/src/main/java/com/microsoft/gctoolkit/time/DateTimeStamp.java b/api/src/main/java/com/microsoft/gctoolkit/time/DateTimeStamp.java
index 0b31fd4..de8d6df 100644
--- a/api/src/main/java/com/microsoft/gctoolkit/time/DateTimeStamp.java
+++ b/api/src/main/java/com/microsoft/gctoolkit/time/DateTimeStamp.java
@@ -8,10 +8,9 @@ import java.time.temporal.TemporalAccessor;
 import java.util.Comparator;
 import java.util.Locale;
 import java.util.Objects;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
-import static java.util.Comparator.*;
+import static java.util.Comparator.comparingDouble;
+import static java.util.Comparator.nullsLast;
 
 
 /**
@@ -22,7 +21,6 @@ import static java.util.Comparator.*;
  * Instance of DateTimeStamp are created by the parser. The constructors match what might be
  * found for dates and time stamps in a GC log file.
  */
-
 public class DateTimeStamp implements Comparable<DateTimeStamp> {
     // Represents the time from Epoch
     // In the case where we have timestamps, the epoch is start of JVM
@@ -42,7 +40,7 @@ public class DateTimeStamp implements Comparable<DateTimeStamp> {
     // For some reason, ISO_DATE_TIME doesn't like that time-zone is -0100. It wants -01:00.
     private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
 
-    private static ZonedDateTime dateFromString(String iso8601DateTime) {
+    private static ZonedDateTime fromString(String iso8601DateTime) {
         if (iso8601DateTime != null) {
             TemporalAccessor temporalAccessor = formatter.parse(iso8601DateTime);
             return ZonedDateTime.from(temporalAccessor);
@@ -50,54 +48,12 @@ public class DateTimeStamp implements Comparable<DateTimeStamp> {
         return null;
     }
 
-    private static double ageFromString(String doubleFormat) {
-        if ( doubleFormat == null) return -1.0d;
-        return Double.parseDouble(doubleFormat.replace(",","."));
-    }
-
-    // Patterns needed to support conversion of a log line to a DateTimeStamp
-
-    private static final String DECIMAL_POINT = "(?:\\.|,)";
-    private static final String INTEGER = "\\d+";
-    private static final String DATE = "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}[\\+|\\-]\\d{4}";
-    private static final String TIME = INTEGER + DECIMAL_POINT + "\\d{3}";
-
-    // Unified Tokens
-    private static final String DATE_TAG = "\\[" + DATE + "\\]";
-    private static final String UPTIME_TAG = "\\[(" + TIME + ")s\\]";
-
-    // Pre-unified tokens
-    private static final String TIMESTAMP = "(" + TIME + "): ";
-    private static final String DATE_STAMP = "(" + DATE + "): ";
-    private static final String DATE_TIMESTAMP = "^(?:" + DATE_STAMP + ")?" + TIMESTAMP;
-
-    //  2017-09-07T09:00:12.795+0200: 0.716:
-    private static final Pattern PREUNIFIED_DATE_TIMESTAMP = Pattern.compile(DATE_TIMESTAMP);
-    // JEP 158 has ISO-8601 time and uptime in seconds and milliseconds as the first two decorators.
-    private static final Pattern UNIFIED_DATE_TIMESTAMP = Pattern.compile("^(" + DATE_TAG + ")?(" + UPTIME_TAG + ")?");
-    private static final DateTimeStamp EMPTY_DATE = new DateTimeStamp(-1.0d);
-
-    public static DateTimeStamp fromGCLogLine(String line) {
-        Matcher matcher;
-        int captureGroup = 2;
-        if ( line.startsWith("[")) {
-            matcher = UNIFIED_DATE_TIMESTAMP.matcher(line);
-            captureGroup = 3;
-        } else
-            matcher = PREUNIFIED_DATE_TIMESTAMP.matcher(line);
-
-        if ( matcher.find())
-            return new DateTimeStamp(dateFromString(matcher.group(1)), ageFromString(matcher.group(captureGroup)));
-        else
-            return EMPTY_DATE;
-    }
-
     /**
      * Create a DateTimeStamp by parsing an ISO 8601 date/time string.
      * @param iso8601DateTime A String in ISO 8601 format.
      */
     public DateTimeStamp(String iso8601DateTime) {
-        this(dateFromString(iso8601DateTime));
+        this(fromString(iso8601DateTime));
     }
 
     /**
@@ -115,7 +71,7 @@ public class DateTimeStamp implements Comparable<DateTimeStamp> {
      * @param timeStamp A time stamp in decimal seconds.
      */
     public DateTimeStamp(String iso8601DateTime, double timeStamp) {
-        this(dateFromString(iso8601DateTime), timeStamp);
+        this(fromString(iso8601DateTime), timeStamp);
     }
 
     /**
@@ -339,19 +295,4 @@ public class DateTimeStamp implements Comparable<DateTimeStamp> {
                             else return dtsA.compareTo(dtsB);
                         });
     }
-
-    public double toEpochInMillis() {
-        if ( dateTime != null) {
-            return (double)(dateTime.toEpochSecond() * 1000) + (((double)dateTime.getNano()) / 1000000.0d);
-        } // todo: a reasonable response here might be????
-        return -1.0d;
-    }
-
-    public boolean hasTimeStamp() {
-        return ! (timeStamp == -1.0d || Double.isNaN(timeStamp));
-    }
-
-    public boolean hasDateTime() {
-        return dateTime != null;
-    }
 }
diff --git a/gclogs/pom.xml b/gclogs/pom.xml
index ee47d15..fc43a31 100644
--- a/gclogs/pom.xml
+++ b/gclogs/pom.xml
@@ -17,7 +17,7 @@
     <packaging>pom</packaging>
 
     <properties>
-        <gctoolkit-testdata-version>1.0.5</gctoolkit-testdata-version>
+        <gctoolkit-testdata-version>1.0.4</gctoolkit-testdata-version>
     </properties>
 
     <build>
diff --git a/IT/pom.xml b/integration/pom.xml
similarity index 91%
rename from IT/pom.xml
rename to integration/pom.xml
index c10f523..9f2a4a1 100644
--- a/IT/pom.xml
+++ b/integration/pom.xml
@@ -62,9 +62,6 @@
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
                 <configuration>
-                    <useModulePath>true</useModulePath>
-                    <!-- todo: Hack to deal with surefire deficiency -->
-                    <argLine>--add-modules=ALL-MODULE-PATH</argLine>
                     <systemProperties>
                         <property>
                             <name>gcLogFile</name>
@@ -79,21 +76,21 @@
                     <outputDirectory>${project.build.directory}/lib</outputDirectory>
                 </configuration>
             </plugin>
-            <plugin>
+            <!-- plugin>
                 <groupId>org.codehaus.mojo</groupId>
                 <artifactId>exec-maven-plugin</artifactId>
                 <configuration>
                     <executable>java</executable>
                     <arguments>
                         <argument>- -module-path</argument>
-                        <!-- Create the modulepath using all project dependencies and project build directory -->
+                        <!- - Create the modulepath using all project dependencies and project build directory - ->
                         <modulepath />
                         <argument>- -module</argument>
                         <argument>com.microsoft.gctoolkit.sample/com.microsoft.gctoolkit.sample.Main</argument>
                         <argument>${gcLogFile}</argument>
                     </arguments>
                 </configuration>
-            </plugin>
+            </plugin -->
         </plugins>
     </build>
 
diff --git a/IT/src/test/java/com/microsoft/gctoolkit/integration/TestMain.java b/integration/src/test/java/com/microsoft/gctoolkit/integration/TestMain.java
similarity index 100%
rename from IT/src/test/java/com/microsoft/gctoolkit/integration/TestMain.java
rename to integration/src/test/java/com/microsoft/gctoolkit/integration/TestMain.java
diff --git a/IT/src/test/java/com/microsoft/gctoolkit/integration/aggregation/TestRuntimeAggregation.java b/integration/src/test/java/com/microsoft/gctoolkit/integration/aggregation/RuntimeAggregationTest.java
similarity index 83%
rename from IT/src/test/java/com/microsoft/gctoolkit/integration/aggregation/TestRuntimeAggregation.java
rename to integration/src/test/java/com/microsoft/gctoolkit/integration/aggregation/RuntimeAggregationTest.java
index ec681f1..e6bf4a8 100644
--- a/IT/src/test/java/com/microsoft/gctoolkit/integration/aggregation/TestRuntimeAggregation.java
+++ b/integration/src/test/java/com/microsoft/gctoolkit/integration/aggregation/RuntimeAggregationTest.java
@@ -1,15 +1,29 @@
 package com.microsoft.gctoolkit.integration.aggregation;
 
+import com.microsoft.gctoolkit.sample.aggregation.RuntimeAggregation;
 import com.microsoft.gctoolkit.time.DateTimeStamp;
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
-public class TestRuntimeAggregation {
+public class RuntimeAggregationTest {
+
+    private static class TestRuntimeAggregation extends RuntimeAggregation {
+
+        @Override
+        public boolean hasWarning() {
+            return false;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+    }
 
     @Test
     public void assertRecordAcceptsNull() {
         final double duration = 1.5d;
-        RuntimeAggregationTest testRuntimeAggregation = new RuntimeAggregationTest();
+        TestRuntimeAggregation testRuntimeAggregation = new TestRuntimeAggregation();
         DateTimeStamp first = new DateTimeStamp(0.0);
         testRuntimeAggregation.record(null, duration);
         DateTimeStamp last = first.add(duration);
@@ -39,7 +53,7 @@ public class TestRuntimeAggregation {
     public void assertRecordAcceptsNaN() {
         final double duration = Double.NaN;
         final double deltaTime = 1.0d;
-        RuntimeAggregationTest testRuntimeAggregation = new RuntimeAggregationTest();
+        TestRuntimeAggregation testRuntimeAggregation = new TestRuntimeAggregation();
         DateTimeStamp first = new DateTimeStamp(0.0d);
         DateTimeStamp last = first.add(deltaTime);
         testRuntimeAggregation.record(first, Double.NaN);
@@ -69,7 +83,7 @@ public class TestRuntimeAggregation {
     public void getTimeOfFirstEvent() {
         final double duration = 1.5d;
         final double deltaTime = 1.0d;
-        RuntimeAggregationTest testRuntimeAggregation = new RuntimeAggregationTest();
+        TestRuntimeAggregation testRuntimeAggregation = new TestRuntimeAggregation();
         DateTimeStamp first = new DateTimeStamp(0.0);
         DateTimeStamp last = first;
         final int nTimes = 10;
@@ -84,7 +98,7 @@ public class TestRuntimeAggregation {
     public void getTimeOfLastEvent() {
         final double duration = 1.5d;
         final double deltaTime = 1.0d;
-        RuntimeAggregationTest testRuntimeAggregation = new RuntimeAggregationTest();
+        TestRuntimeAggregation testRuntimeAggregation = new TestRuntimeAggregation();
         final DateTimeStamp first = new DateTimeStamp(0.0);
         DateTimeStamp next = first;
         final int nTimes = 10;
@@ -100,7 +114,7 @@ public class TestRuntimeAggregation {
     public void getRuntimeDuration() {
         final double duration = 1.5d;
         final double deltaTime = 1.0d;
-        RuntimeAggregationTest testRuntimeAggregation = new RuntimeAggregationTest();
+        TestRuntimeAggregation testRuntimeAggregation = new TestRuntimeAggregation();
         final DateTimeStamp first = new DateTimeStamp(0.0);
         DateTimeStamp next = first;
         final int nTimes = 10;
@@ -108,7 +122,8 @@ public class TestRuntimeAggregation {
             testRuntimeAggregation.record(next, duration);
             next = next.add(deltaTime);
         }
-        double totalDuration = testRuntimeAggregation.getTimeOfLastEvent().minus(testRuntimeAggregation.getTimeOfFirstEvent());
+        double totalDuration =
+                testRuntimeAggregation.getTimeOfLastEvent().minus(testRuntimeAggregation.getTimeOfFirstEvent());
         Assertions.assertEquals(totalDuration, testRuntimeAggregation.getRuntimeDuration());
     }
 }
\ No newline at end of file
diff --git a/IT/src/test/java/com/microsoft/gctoolkit/integration/collections/XYDataSetTest.java b/integration/src/test/java/com/microsoft/gctoolkit/integration/collections/XYDataSetTest.java
similarity index 93%
rename from IT/src/test/java/com/microsoft/gctoolkit/integration/collections/XYDataSetTest.java
rename to integration/src/test/java/com/microsoft/gctoolkit/integration/collections/XYDataSetTest.java
index 4a33cd7..a66ee63 100644
--- a/IT/src/test/java/com/microsoft/gctoolkit/integration/collections/XYDataSetTest.java
+++ b/integration/src/test/java/com/microsoft/gctoolkit/integration/collections/XYDataSetTest.java
@@ -7,6 +7,9 @@ import com.microsoft.gctoolkit.sample.collections.XYDataSet.Point;
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
 public class XYDataSetTest {
 
     @Test
diff --git a/IT/src/test/java/com/microsoft/gctoolkit/integration/io/RotatingGarbageCollectionLogFileTest.java b/integration/src/test/java/com/microsoft/gctoolkit/integration/io/RotatingGarbageCollectionLogFileTest.java
similarity index 59%
rename from IT/src/test/java/com/microsoft/gctoolkit/integration/io/RotatingGarbageCollectionLogFileTest.java
rename to integration/src/test/java/com/microsoft/gctoolkit/integration/io/RotatingGarbageCollectionLogFileTest.java
index 82243c9..6e762c3 100644
--- a/IT/src/test/java/com/microsoft/gctoolkit/integration/io/RotatingGarbageCollectionLogFileTest.java
+++ b/integration/src/test/java/com/microsoft/gctoolkit/integration/io/RotatingGarbageCollectionLogFileTest.java
@@ -2,13 +2,20 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.integration.io;
 
-import com.microsoft.gctoolkit.io.LogFileSegment;
+import com.microsoft.gctoolkit.io.GCLogFileSegment;
 import com.microsoft.gctoolkit.io.RotatingGCLogFile;
 import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
 import java.nio.file.Path;
+import java.nio.file.PathMatcher;
+import java.nio.file.Paths;
 import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.fail;
@@ -46,64 +53,73 @@ public class RotatingGarbageCollectionLogFileTest {
             }
     };
 
-    @Test
+    //@Test
     public void getOrderedGarbageCollectionLogFiles() {
         for(String[] data : expected) {
             try {
-                TestLogFile logFile = new TestLogFile(data[0]);
-                RotatingGCLogFile garbageCollectionLogFile = new RotatingGCLogFile(logFile.getFile().toPath());
-                List<LogFileSegment> segments = garbageCollectionLogFile.getOrderedGarbageCollectionLogFiles();
+                RotatingGCLogFile garbageCollectionLogFile = createRotatingGarbageCollectionLogFile(data[0]);
+                List<GCLogFileSegment> segments = garbageCollectionLogFile.getOrderedGarbageCollectionLogFiles();
                 assertEquals(data.length - 1, segments.size());
                 for (int n = 1; n < data.length; n++) {
                     assertEquals(data[n], segments.get(n - 1).getPath().getFileName().toString());
                 }
-            } catch (Throwable e) {
+            } catch (IOException e) {
                 fail(e);
             }
         }
     }
 
-    private void runRollingLogOrderingTest(Path path, List<String> expectedOrdering, long lineCount) {
+    //@Test
+    public void testRollingLogOrderUsage() {
+        Path path = getPath( "rolling/jdk14/rollinglogs/rollover.log");
+        List<String> expected = Arrays.asList(
+                "rollover.log.3", "rollover.log.4", "rollover.log.0", "rollover.log.1", "rollover.log.2", "rollover.log"
+        );
         try {
             RotatingGCLogFile rotatingGCLogFile = new RotatingGCLogFile(path);
             List<String> actual =
                     rotatingGCLogFile
                             .getOrderedGarbageCollectionLogFiles()
                             .stream()
-                            .map(segment -> segment.getSegmentName())
+                            .map(segment -> segment.getPath().getFileName().toString())
                             .collect(Collectors.toList());
-            assertEquals(expectedOrdering, actual);
-            long count = rotatingGCLogFile.stream().count();
-            assertEquals(246732,count,"Unequal line counts");
+            assertEquals(expected, actual);
         } catch (Exception badTestData) {
             fail(badTestData);
         }
     }
 
-    @Test
-    public void testRollingLogOrderUsage() {
-        Path path = new TestLogFile("rolling/jdk14/rollinglogs/rollover.log").getFile().toPath();
-        List<String> expected = Arrays.asList(
-                "rollover.log.3", "rollover.log.4", "rollover.log.0", "rollover.log.1", "rollover.log.2", "rollover.log"
-        );
-        runRollingLogOrderingTest(path, expected, 246732);
+    static RotatingGCLogFile createRotatingGarbageCollectionLogFile(String partialPath) throws IOException {
+        Path path = getPath(partialPath);
+        List<GCLogFileSegment> segments = getSegments(path);
+        return new RotatingGCLogFile(path.getParent(), segments);
     }
 
-    @Test
-    public void testRollingInZip() {
-        Path path = new TestLogFile("rolling/jdk14/rollinglogs/zip/rollover.zip").getFile().toPath();
-        List<String> expected = Arrays.asList(
-                "rollover.log.3", "rollover.log.4", "rollover.log.0", "rollover.log.1", "rollover.log.2", "rollover.log"
-        );
-        runRollingLogOrderingTest(path,expected, 246732);
+    static final String[] roots = new String[] {
+            "./gclogs/",
+            "../gclogs/",
+            "../../gclogs/"
+    };
+
+    static Path getPath(String filename) {
+        return Arrays.stream(roots)
+                .map(path -> Paths.get(path, filename))
+                .filter(Files::exists)
+                .findFirst()
+                .orElseThrow(() -> new RuntimeException(filename + " not found"));
     }
 
-    @Test
-    public void testRollingInDirInZip() {
-        Path path = new TestLogFile("rolling/jdk14/rollinglogs/zip/rolloverdir.zip").getFile().toPath();
-        List<String> expected = Arrays.asList(
-                "rollover/rollover.log.3", "rollover/rollover.log.4", "rollover/rollover.log.0", "rollover/rollover.log.1", "rollover/rollover.log.2", "rollover/rollover.log"
-        );
-        runRollingLogOrderingTest(path,expected, 246732);
+    static List<GCLogFileSegment> getSegments(Path path) {
+        Path directory = path.getParent();
+        String filename = path.getFileName().toString();
+        PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher("glob:"+filename+"*");
+        try (Stream<Path> stream = Files.list(directory)) {
+            return stream.filter(p -> pathMatcher.matches(p.getFileName()))
+                    .map(GCLogFileSegment::new)
+                    .collect(Collectors.toList());
+        } catch (IOException e) {
+            // autoclose...
+            return List.of();
+        }
     }
 }
diff --git a/IT/src/test/java/com/microsoft/gctoolkit/integration/io/SingleGarbageCollectionLogFileTest.java b/integration/src/test/java/com/microsoft/gctoolkit/integration/io/SingleGarbageCollectionLogFileTest.java
similarity index 60%
rename from IT/src/test/java/com/microsoft/gctoolkit/integration/io/SingleGarbageCollectionLogFileTest.java
rename to integration/src/test/java/com/microsoft/gctoolkit/integration/io/SingleGarbageCollectionLogFileTest.java
index deecbff..ef63d89 100644
--- a/IT/src/test/java/com/microsoft/gctoolkit/integration/io/SingleGarbageCollectionLogFileTest.java
+++ b/integration/src/test/java/com/microsoft/gctoolkit/integration/io/SingleGarbageCollectionLogFileTest.java
@@ -2,13 +2,22 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.integration.io;
 
+import com.microsoft.gctoolkit.io.GCLogFileSegment;
 import com.microsoft.gctoolkit.io.LogFileMetadata;
 import com.microsoft.gctoolkit.io.SingleGCLogFile;
 import com.microsoft.gctoolkit.jvm.Diary;
 import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
 import java.nio.file.Path;
+import java.nio.file.PathMatcher;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import static org.junit.jupiter.api.Assertions.*;
 
@@ -20,7 +29,7 @@ public class SingleGarbageCollectionLogFileTest {
     @Test
     public void unifiedLog() {
         for(String log : unifiedLogs) {
-            Path path = new TestLogFile(log).getFile().toPath();
+            Path path = getPath(log);
             SingleGCLogFile gcLogFile = new SingleGCLogFile(path);
             assertEquals(true, gcLogFile.isUnified(), "Expected unified but failed");
             try {
@@ -56,4 +65,32 @@ public class SingleGarbageCollectionLogFileTest {
             }
         }
     }
+
+    static final String[] roots = new String[] {
+            "./gclogs/",
+            "../gclogs/",
+            "../../gclogs/"
+    };
+
+    static Path getPath(String filename) {
+        return Arrays.stream(roots)
+                .map(path -> Paths.get(path, filename))
+                .filter(Files::exists)
+                .findFirst()
+                .orElseThrow(() -> new RuntimeException(filename + " not found"));
+    }
+
+    static List<GCLogFileSegment> getSegments(Path path) {
+        Path directory = path.getParent();
+        String filename = path.getFileName().toString();
+        PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher("glob:"+filename+"*");
+        try (Stream<Path> stream = Files.list(directory)) {
+            return stream.filter(p -> pathMatcher.matches(p.getFileName()))
+                    .map(GCLogFileSegment::new)
+                    .collect(Collectors.toList());
+        } catch (IOException e) {
+            // autoclose...
+            return List.of();
+        }
+    }
 }
diff --git a/IT/src/test/java/module-info.java b/integration/src/test/java/module-info.java
similarity index 79%
rename from IT/src/test/java/module-info.java
rename to integration/src/test/java/module-info.java
index 2ee6cef..866d7b8 100644
--- a/IT/src/test/java/module-info.java
+++ b/integration/src/test/java/module-info.java
@@ -1,12 +1,10 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import com.microsoft.gctoolkit.integration.aggregation.RuntimeAggregationTestSupport;
-
 /*
  Module for the purposes of housing tests that need to be in a module in order to run.
  */
-open module com.microsoft.gctoolkit.integration {
+module com.microsoft.gctoolkit.integration {
 
     requires com.microsoft.gctoolkit.api;
     requires com.microsoft.gctoolkit.parser;
@@ -21,6 +19,6 @@ open module com.microsoft.gctoolkit.integration {
             com.microsoft.gctoolkit.vertx;
 
     provides com.microsoft.gctoolkit.aggregator.Aggregation with
-            RuntimeAggregationTest;
+            com.microsoft.gctoolkit.integration.aggregation.RuntimeAggregationTestSupport;
 
 }
\ No newline at end of file
diff --git a/parser/src/main/java/com/microsoft/gctoolkit/parser/GenerationalHeapParser.java b/parser/src/main/java/com/microsoft/gctoolkit/parser/GenerationalHeapParser.java
index a8d7f15..0f6b17c 100644
--- a/parser/src/main/java/com/microsoft/gctoolkit/parser/GenerationalHeapParser.java
+++ b/parser/src/main/java/com/microsoft/gctoolkit/parser/GenerationalHeapParser.java
@@ -299,28 +299,46 @@ public class GenerationalHeapParser extends PreUnifiedGCLogParser implements Sim
         log(line);
     }
 
+    // TODO #151 populate with lines that should be ignored
+    // private boolean inPrintHeapAtGC = false;
+
     private boolean ignoreFrequentButUnwantedEntries(String line) {
 
+//         if ( deriveConfiguration.hasApplicationRunningTime()) {
         if (JVMPatterns.APPLICATION_TIME.parse(line) != null) return true;
         if (JVMPatterns.SIMPLE_APPLICATION_TIME.parse(line) != null) return true;
+        //         }
 
+//         if ( deriveConfiguration.hasApplicationStoppedTime()) {
         if (JVMPatterns.APPLICATION_STOP_TIME.parse(line) != null) return true;
         if (JVMPatterns.APPLICATION_STOP_TIME_WITH_STOPPING_TIME.parse(line) != null) return true;
         if (JVMPatterns.SIMPLE_APPLICATION_STOP_TIME.parse(line) != null) return true;
+//         }
 
+//         if ( deriveConfiguration.hasTenuringDistribution()) {
         if (TenuredPatterns.TENURING_SUMMARY.parse(line) != null) return true;
         if (TenuredPatterns.TENURING_AGE_BREAKDOWN.parse(line) != null) return true;
+//         }
+
+//         if ( ! deriveConfiguration.isJDK70()) {
+//             if ( line.contains("Metaspace ")) return true;
+//             if ( line.contains("class space ")) return true;
+//         }
 
         if (line.startsWith("TLAB: gc thread: ")) return true;
         if (line.startsWith("TLAB totals: thrds: ")) return true;
 
+//         if ( deriveConfiguration.hasPrintHeapAtGC()) {
         if (line.startsWith("{Heap before")) {
+            // inPrintHeapAtGC = true;
             return true;
         }
         if (line.equals("}")) {
+            // inPrintHeapAtGC = false;
             return true;
         }
 
+//             if ( inPrintHeapAtGC) {
         if (line.startsWith("Heap after")) return true;
         if (line.startsWith("PSYoungGen")) return true;
         if (line.startsWith("ParOldGen")) return true;
@@ -331,8 +349,11 @@ public class GenerationalHeapParser extends PreUnifiedGCLogParser implements Sim
         if (line.startsWith("from space")) return true;
         if (line.startsWith("to   space")) return true;
         if (line.contains("[0xffff") && line.endsWith("000)")) ;
+//             }
 
+        // TODO #152 remove when we start collecting this information
         if (line.startsWith("Finished ")) return true;
+//         }
 
         if (line.startsWith("GC locker: Trying a full collection because scavenge failed")) return true;
 
diff --git a/parser/src/main/java/com/microsoft/gctoolkit/parser/io/SafepointLogFile.java b/parser/src/main/java/com/microsoft/gctoolkit/parser/io/SafepointLogFile.java
index 19e7c90..3268bb4 100644
--- a/parser/src/main/java/com/microsoft/gctoolkit/parser/io/SafepointLogFile.java
+++ b/parser/src/main/java/com/microsoft/gctoolkit/parser/io/SafepointLogFile.java
@@ -4,6 +4,7 @@ package com.microsoft.gctoolkit.parser.io;
 
 import com.microsoft.gctoolkit.io.DataSource;
 import com.microsoft.gctoolkit.io.LogFileMetadata;
+import com.microsoft.gctoolkit.io.SingleLogFileMetadata;
 import com.microsoft.gctoolkit.io.GCLogFile;
 import com.microsoft.gctoolkit.jvm.Diary;
 
@@ -26,6 +27,11 @@ public class SafepointLogFile implements DataSource<String> {
 
     public SafepointLogFile(Path path) {
         this.path = path;
+//        try {
+//            this.metadata = new SingleLogFileMetadata(path);
+//        } catch (IOException e) {
+//            e.printStackTrace();
+//        }
     }
 
     /**
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/ConcurrentMarkSweepParserRulesTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/ConcurrentMarkSweepParserRulesTest.java
index fa35825..1128a32 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/ConcurrentMarkSweepParserRulesTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/ConcurrentMarkSweepParserRulesTest.java
@@ -32,7 +32,7 @@ public class ConcurrentMarkSweepParserRulesTest implements CMSPatterns {
 
     private final boolean debugging = Boolean.getBoolean("microsoft.debug");
 
-    // @Test
+    //@Test
     //@Ignore("Not a real test, only for debugging")
     public void testDebugCMSParseRule() {
         int index = rules.length-1; // awesome fix from David.. thanks :-)
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/G1GCParserRulesTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/G1GCParserRulesTest.java
index b3c9f27..bc72388 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/G1GCParserRulesTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/G1GCParserRulesTest.java
@@ -27,7 +27,7 @@ public class G1GCParserRulesTest implements G1GCPatterns {
         assertTrue(true);
     }
 
-    //  test for debugging only... @Test
+    //@Test
     public void testSingeRule() {
         int index = 35;
         assertEquals(1, CommonTestHelper.captureTest(rules[index], lines[index]));
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/G1GCUnifiedParserRulesTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/G1GCUnifiedParserRulesTest.java
index 5ff38a0..7bab893 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/G1GCUnifiedParserRulesTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/G1GCUnifiedParserRulesTest.java
@@ -39,7 +39,7 @@ public class G1GCUnifiedParserRulesTest implements UnifiedG1GCPatterns {
         assertTrue(true);
     }
 
-    @Test
+    //@Test
     public void testUnifiedLoggingDecorators() {
         for (String decoratorLine : decoratorLines) {
             Decorators decorators = new Decorators(decoratorLine);
@@ -47,13 +47,13 @@ public class G1GCUnifiedParserRulesTest implements UnifiedG1GCPatterns {
         }
     }
 
-    // for debugging @Test
+    //@Test
     public void testSingeRuleCapture() {
         int index = 10;
         assertEquals(lines[index].length, captureTest(rules[index], lines[index]), "Miss for " + rules[index].getName());
     }
 
-    // for debugging @Test
+    //@Test
     public void testSingleRuleMisses() {
         int index = 10;
         for (int i = 0; i < rules.length; i++)
@@ -61,7 +61,7 @@ public class G1GCUnifiedParserRulesTest implements UnifiedG1GCPatterns {
                 assertEquals(0, captureTest(rules[index], lines[i]), rules[index].getName() + " hits on lines for " + rules[i].getName());
     }
 
-    // for debugging @Test
+    //@Test
     public void testSingleRule() {
         testSingeRuleCapture();
         testSingleRuleMisses();
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/ParallelParserRulesTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/ParallelParserRulesTest.java
index 283728b..3d0669c 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/ParallelParserRulesTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/ParallelParserRulesTest.java
@@ -31,7 +31,7 @@ public class ParallelParserRulesTest implements ParallelPatterns {
 
     private final boolean debugging = Boolean.getBoolean("microsoft.debug");
 
-    // @Test
+    //@Test
     public void testDebugParallelParseRules() {
         int index = 4;
         GCParseRule rule = rules[index];
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/ShenandoahParserRulesTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/ShenandoahParserRulesTest.java
index e169abe..9a7a75d 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/ShenandoahParserRulesTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/ShenandoahParserRulesTest.java
@@ -40,7 +40,7 @@ public class ShenandoahParserRulesTest implements ShenandoahPatterns {
     }
 
     // Convenience test for debugging single rules
-    // @Test
+    //@Test
     public void testSingeRule() {
         int index = 9;
         assertEquals(captureTest(rules[index], lines[index]), lines[index].length);
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/TestLogFile.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/TestLogFile.java
similarity index 97%
rename from parser/src/test/java/com/microsoft/gctoolkit/parser/diary/TestLogFile.java
rename to parser/src/test/java/com/microsoft/gctoolkit/parser/TestLogFile.java
index 1aba66f..4dbd1ea 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/TestLogFile.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/TestLogFile.java
@@ -1,6 +1,6 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
-package com.microsoft.gctoolkit.parser.diary;
+package com.microsoft.gctoolkit.parser;
 
 import java.io.File;
 import java.util.Arrays;
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/UnifiedGenerationalParserRulesTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/UnifiedGenerationalParserRulesTest.java
index b0856bf..92cc30a 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/UnifiedGenerationalParserRulesTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/UnifiedGenerationalParserRulesTest.java
@@ -39,7 +39,7 @@ public class UnifiedGenerationalParserRulesTest implements UnifiedGenerationalPa
     }
 
     // Convenience test for debugging single rules
-    // @Test
+    //@Test
     public void testSingeRule() {
         int index = 0;
         assertEquals(4, captureTest(rules[index], lines[index]));
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/ZGCParserRulesTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/ZGCParserRulesTest.java
index 7d98d0d..22e6e4d 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/ZGCParserRulesTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/ZGCParserRulesTest.java
@@ -49,7 +49,7 @@ public class ZGCParserRulesTest implements ZGCPatterns {
     }
 
     // Convenience test for debugging single rules
-    // @Test
+    //@Test
     public void testSingeRule() {
         int index = 14;
         assertEquals(captureTest(rules[index], lines[index]), lines[index].length);
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSDefNewLogDiaryTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSDefNewLogDiaryTest.java
index 9d2521c..b667460 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSDefNewLogDiaryTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSDefNewLogDiaryTest.java
@@ -4,6 +4,7 @@ package com.microsoft.gctoolkit.parser.diary;
 
 import com.microsoft.gctoolkit.io.SingleGCLogFile;
 import com.microsoft.gctoolkit.jvm.Diarizer;
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 import static org.junit.jupiter.api.Assertions.fail;
@@ -28,20 +29,20 @@ public class CMSDefNewLogDiaryTest extends LogDiaryTest {
     }
 
 
-    private final String[] cmsDefNewDetails = {
+    private static final String[] cmsDefNewDetails = {
             "cms/defnew/details/defnew.log"
     };
 
-    private final boolean[][] cmsDefNewDetailsDiary = {
+    private static final boolean[][] cmsDefNewDetailsDiary = {
             //   0      1     2      3     4      5      6      7      8      9     10     11    12     13     14     15     16    17     18     19     20     21     22     23     24     25     26     27
             {false, false, true, false, true, false, false, false, false, false, false, false, true, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false}
     };
 
-    private final int[][] cmsDefNewDetailsUnknown = {
+    private static final int[][] cmsDefNewDetailsUnknown = {
             {18}
     };
 
-    private final int[][] cmsDefNewDetailsKnown = {
+    private static final int[][] cmsDefNewDetailsKnown = {
             {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24,25,26,27}
     };
 }
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSLogDiaryTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSLogDiaryTest.java
index b0a59be..0e05082 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSLogDiaryTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSLogDiaryTest.java
@@ -4,6 +4,7 @@ package com.microsoft.gctoolkit.parser.diary;
 
 import com.microsoft.gctoolkit.io.SingleGCLogFile;
 import com.microsoft.gctoolkit.jvm.Diarizer;
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
@@ -30,7 +31,7 @@ public class CMSLogDiaryTest extends LogDiaryTest {
     }
 
 
-    private final String[] cms = {
+    private static final String[] cms = {
             "530_gc.log",
             "718_SERVER.gc_100315_163149.log",
             "862_gc.log",
@@ -42,7 +43,7 @@ public class CMSLogDiaryTest extends LogDiaryTest {
             "939_par.cms.nd.wt.log"
     };
 
-    private final boolean[][] cmsDiary = {
+    private static final boolean[][] cmsDiary = {
             //    0      1      2    3     4      5      6      7      8      9     10     11     12     13     14     15     16     17     18     19     20     21     22     23     24     25     26     27
             {false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
             {false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
@@ -55,7 +56,7 @@ public class CMSLogDiaryTest extends LogDiaryTest {
             {false, false, false, true, true, false, false, false, false, false, false, false, false,  true, false, false, false, false, false, false, false, false, false, false, false, false, false, false}
     };
 
-    private final int[][] cmsUnknown = {
+    private static final int[][] cmsUnknown = {
             {-1},
             {-1},
             {-1},
@@ -67,7 +68,7 @@ public class CMSLogDiaryTest extends LogDiaryTest {
             {-1}
     };
 
-    private final int[][] cmsKnown = {
+    private static final int[][] cmsKnown = {
             {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27},
             {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27},
             {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27},
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSParNewLogDiaryTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSParNewLogDiaryTest.java
index 4134ef3..4f32aff 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSParNewLogDiaryTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/CMSParNewLogDiaryTest.java
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.diary;
 
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 public class CMSParNewLogDiaryTest extends LogDiaryTest {
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/G1DiarizerTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/G1DiarizerTest.java
index ede643d..7ea8bdb 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/G1DiarizerTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/G1DiarizerTest.java
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.diary;
 
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 public class G1DiarizerTest extends LogDiaryTest {
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/LogDiaryTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/LogDiaryTest.java
index 11a77eb..74260b6 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/LogDiaryTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/LogDiaryTest.java
@@ -7,6 +7,7 @@ import com.microsoft.gctoolkit.io.SingleGCLogFile;
 import com.microsoft.gctoolkit.jvm.Diarizer;
 import com.microsoft.gctoolkit.jvm.Diary;
 import com.microsoft.gctoolkit.jvm.SupportedFlags;
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import com.microsoft.gctoolkit.parser.jvm.PreUnifiedDiarizer;
 import com.microsoft.gctoolkit.parser.jvm.UnifiedDiarizer;
 
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/SerialDefNewLogDiaryTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/SerialDefNewLogDiaryTest.java
index 3cb2312..9062a02 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/SerialDefNewLogDiaryTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/SerialDefNewLogDiaryTest.java
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.diary;
 
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 public class SerialDefNewLogDiaryTest extends LogDiaryTest {
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/ShenandoahLogDiaryTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/ShenandoahLogDiaryTest.java
index 21875e0..360ed8e 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/ShenandoahLogDiaryTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/ShenandoahLogDiaryTest.java
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.diary;
 
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 public class ShenandoahLogDiaryTest extends LogDiaryTest {
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/VerboseLogDiaryTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/VerboseLogDiaryTest.java
index 8f670ae..513507f 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/VerboseLogDiaryTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/VerboseLogDiaryTest.java
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.diary;
 
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 public class VerboseLogDiaryTest extends LogDiaryTest {
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/ZGCLogDiaryTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/ZGCLogDiaryTest.java
index 0184d75..4e43cdf 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/ZGCLogDiaryTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/diary/ZGCLogDiaryTest.java
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.diary;
 
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 public class ZGCLogDiaryTest extends LogDiaryTest {
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/CMSParNewParserTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/CMSParNewParserTest.java
index 20bef62..e451845 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/CMSParNewParserTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/CMSParNewParserTest.java
@@ -2,7 +2,8 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.unittests;
 
-import com.microsoft.gctoolkit.parser.diary.TestLogFile;
+
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/G1GCMetaspaceTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/G1GCMetaspaceTest.java
index 18f7ebf..bf993f6 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/G1GCMetaspaceTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/G1GCMetaspaceTest.java
@@ -2,7 +2,8 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.unittests;
 
-import com.microsoft.gctoolkit.parser.diary.TestLogFile;
+
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/ICMSParNewParserTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/ICMSParNewParserTest.java
index bf968fc..f2b0d9a 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/ICMSParNewParserTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/ICMSParNewParserTest.java
@@ -2,7 +2,8 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.unittests;
 
-import com.microsoft.gctoolkit.parser.diary.TestLogFile;
+
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/ParallelCollectorParserTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/ParallelCollectorParserTest.java
index 2e0b390..fc7f8e9 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/ParallelCollectorParserTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/ParallelCollectorParserTest.java
@@ -3,29 +3,22 @@
 package com.microsoft.gctoolkit.parser.unittests;
 
 
-import com.microsoft.gctoolkit.parser.diary.TestLogFile;
-import org.junit.jupiter.api.Test;
-
-import java.io.IOException;
-import java.nio.file.Path;
-
-import static org.junit.jupiter.api.Assertions.fail;
-
 public class ParallelCollectorParserTest extends ParserTest {
-
-    @Test
-    public void testForDetailsTenuringGCCause170() {
-        int i = 0;
-        for ( String name : detailsTenuringGCCause170) {
-            try {
-                Path path = new TestLogFile("ps/details/tenuring/gccause/170/" + name).getFile().toPath();
-                TestResults testResults = testGenerationalSingleLogFile( path);
-                analyzeResults(path.toFile().getAbsolutePath(),testResults, detailsTenuringGCCause170CountsNumberOfDifferentCollectors[i], detailsTenuringGCCause170Counts[i++]);
-            } catch (IOException ioe) {
-                fail(ioe.getMessage());
+    /*
+        @Test
+        public void testForDetailsTenuringGCCause170() {
+            int i = 0;
+            for ( String name : detailsTenuringGCCause170) {
+                try {
+                    Path path = new TestLogFile("ps/details/tenuring/gccause/170/" + name).getFile().toPath();
+                    TestResults testResults = testGenerationalSingleLogFile( path);
+                    analyzeResults(testResults, detailsTenuringGCCause170CountsNumberOfDifferentCollectors[i], detailsTenuringGCCause170Counts[i++]);
+                } catch (IOException ioe) {
+                    fail(ioe.getMessage());
+                }
             }
         }
-    }
+    */
     private static final String[] detailsTenuringGCCause170 = {
             "ps.cause.tenuring.details.v17051.log",
             "ps.dates.cause.tenuring.details.v17051.log",
@@ -42,21 +35,21 @@ public class ParallelCollectorParserTest extends ParserTest {
             {0, 0, 0, 0, 0, 0, 0, 90, 4, 0, 0, 0, 0},
             {0, 0, 0, 0, 0, 0, 0, 95, 3, 0, 0, 0, 0}
     };
-
-    @Test
-    public void testForDetails() {
-        int i = 0;
-        for ( String name : details) {
-            try {
-                Path path = new TestLogFile("ps/details/" + name).getFile().toPath();
-                TestResults testResults = testGenerationalSingleLogFile( path);
-                analyzeResults(path.toFile().getAbsolutePath(),testResults, detailsNumberOfDifferentCollectors[i], detailsCounts[i++]);
-            } catch (IOException ioe) {
-                fail(ioe.getMessage());
+    /*
+        @Test
+        public void testForDetails() {
+            int i = 0;
+            for ( String name : details) {
+                try {
+                    Path path = new TestLogFile("ps/details/" + name).getFile().toPath();
+                    TestResults testResults = testGenerationalSingleLogFile( path);
+                    analyzeResults(testResults, detailsNumberOfDifferentCollectors[i], detailsCounts[i++]);
+                } catch (IOException ioe) {
+                    fail(ioe.getMessage());
+                }
             }
         }
-    }
-
+    */
     private static final String[] details = {
             "long_pause.log"
     };
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/PreunifiedG1GCParserTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/PreunifiedG1GCParserTest.java
index ef6b674..7a1ecd8 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/PreunifiedG1GCParserTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/PreunifiedG1GCParserTest.java
@@ -2,7 +2,8 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.unittests;
 
-import com.microsoft.gctoolkit.parser.diary.TestLogFile;
+
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/UnifiedG1GCParserTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/UnifiedG1GCParserTest.java
index 4d1936b..5d794d1 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/UnifiedG1GCParserTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/UnifiedG1GCParserTest.java
@@ -2,7 +2,7 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.unittests;
 
-import com.microsoft.gctoolkit.parser.diary.TestLogFile;
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
diff --git a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/UnifiedGenerationalParserTest.java b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/UnifiedGenerationalParserTest.java
index f762bfd..3c68b21 100644
--- a/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/UnifiedGenerationalParserTest.java
+++ b/parser/src/test/java/com/microsoft/gctoolkit/parser/unittests/UnifiedGenerationalParserTest.java
@@ -2,7 +2,7 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.parser.unittests;
 
-import com.microsoft.gctoolkit.parser.diary.TestLogFile;
+import com.microsoft.gctoolkit.parser.TestLogFile;
 import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
diff --git a/pom.xml b/pom.xml
index e109cad..365e8e4 100644
--- a/pom.xml
+++ b/pom.xml
@@ -60,7 +60,7 @@
         <module>parser</module>
         <module>vertx</module>
         <module>sample</module>
-        <module>IT</module>
+        <module>integration</module>
     </modules>
 
     <properties>
@@ -88,7 +88,7 @@
         <maven.resources-plugin.version>3.2.0</maven.resources-plugin.version>
         <maven.site-plugin.version>3.9.1</maven.site-plugin.version>
         <maven.spotbugs-plugin.version>4.3.0</maven.spotbugs-plugin.version>
-        <maven.surefire-plugin.version>3.0.0-M5</maven.surefire-plugin.version> <!-- 3.0.0-M3 -->
+        <maven.surefire-plugin.version>3.0.0-M5</maven.surefire-plugin.version>
         <directory-maven-plugin.version>0.3.1</directory-maven-plugin.version>
         <maven.version>3.8.2</maven.version>
         <maven.versions-plugin.version>2.8.1</maven.versions-plugin.version>
@@ -98,6 +98,7 @@
         <spotbugs.version>4.4.1</spotbugs.version>
         <project.github.repository>microsoft/gctoolkit</project.github.repository>
         <repository.url>git@github.com:${project.github.repository}.git</repository.url>
+        <jreleaser.plugin.version>0.8.0</jreleaser.plugin.version>
     </properties>
 
     <dependencyManagement>
@@ -122,6 +123,7 @@
                 <artifactId>gctoolkit-gclogs</artifactId>
                 <version>${project.version}</version>
             </dependency>
+
             <dependency>
                 <groupId>org.junit.jupiter</groupId>
                 <artifactId>junit-jupiter-engine</artifactId>
@@ -171,7 +173,7 @@
                         <dependency>
                             <groupId>com.puppycrawl.tools</groupId>
                             <artifactId>checkstyle</artifactId>
-                            <version>9.1</version>
+                            <version>${checkstyle.version}</version>
                         </dependency>
                     </dependencies>
                 </plugin>
@@ -494,6 +496,66 @@
                 </plugins>
             </build>
         </profile>
+        <profile>
+            <id>jreleaser</id>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.jreleaser</groupId>
+                        <artifactId>jreleaser-maven-plugin</artifactId>
+                        <version>${jreleaser.plugin.version}</version>
+                        <inherited>false</inherited>
+                        <configuration>
+                            <jreleaser>
+                                <release>
+                                    <github>
+                                        <tagName>gctoolkit-{{projectVersion}}</tagName>
+                                        <skipTag>true</skipTag>
+                                        <changelog>
+                                            <formatted>ALWAYS</formatted>
+                                            <preset>conventional-commits</preset>
+                                            <labelers>
+                                                <labeler>
+                                                    <label>maven-release</label>
+                                                    <title>[maven-release-plugin]</title>
+                                                </labeler>
+                                                <labeler>
+                                                    <label>github-issue</label>
+                                                    <title>#</title>
+                                                </labeler>
+                                            </labelers>
+                                            <categories>
+                                                <category>
+                                                    <title>maven-release</title>
+                                                    <labels>maven-release</labels>
+                                                </category>
+                                                <category>
+                                                    <title>Changes</title>
+                                                    <labels>github-issue</labels>
+                                                </category>
+                                            </categories>
+                                            <contributors>
+                                                <format>
+                                                    - {{contributorName}}{{#contributorUsernameAsLink}} ({{.}}){{/contributorUsernameAsLink}}
+                                                </format>
+                                            </contributors>
+                                            <hide>
+                                                <contributors>
+                                                    GitHub
+                                                </contributors>
+                                                <categories>
+                                                    maven-release
+                                                </categories>
+                                            </hide>
+                                        </changelog>
+                                    </github>
+                                </release>
+                            </jreleaser>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
     </profiles>
 
 </project>
diff --git a/sample/src/main/java/com/microsoft/gctoolkit/sample/Main.java b/sample/src/main/java/com/microsoft/gctoolkit/sample/Main.java
index 3dd6817..c5290c3 100644
--- a/sample/src/main/java/com/microsoft/gctoolkit/sample/Main.java
+++ b/sample/src/main/java/com/microsoft/gctoolkit/sample/Main.java
@@ -59,20 +59,6 @@ public class Main {
                 .ifPresent(summary -> {
                     summary.forEach((gcType, dataSet) -> {
                         System.out.printf(message, gcType, dataSet.size());
-                        switch (gcType) {
-                            case DefNew:
-                                defNewCount = dataSet.size();
-                                break;
-                            case InitialMark:
-                                initialMarkCount = dataSet.size();
-                                break;
-                            case Remark:
-                                remarkCount = dataSet.size();
-                                break;
-                            default:
-                                System.out.println(gcType + " not managed");
-                                break;
-                        }
                     });
                 });
 
@@ -102,4 +88,5 @@ public class Main {
     public int getDefNewCount() {
         return defNewCount;
     }
+
 }
diff --git a/sample/src/main/java/com/microsoft/gctoolkit/sample/aggregation/HeapOccupancyAfterCollection.java b/sample/src/main/java/com/microsoft/gctoolkit/sample/aggregation/HeapOccupancyAfterCollection.java
index 3451b42..2cd6559 100644
--- a/sample/src/main/java/com/microsoft/gctoolkit/sample/aggregation/HeapOccupancyAfterCollection.java
+++ b/sample/src/main/java/com/microsoft/gctoolkit/sample/aggregation/HeapOccupancyAfterCollection.java
@@ -33,7 +33,7 @@ public class HeapOccupancyAfterCollection extends Aggregator<HeapOccupancyAfterC
     }
 
     private void extractHeapOccupancy(ShenandoahCycle event) {
-        //aggregation().addDataPoint(event.getGarbageCollectionType(), event.getDateTimeStamp(), event.getOccupancy());
+        //aggregation.addDataPoint(event.getGarbageCollectionType(), event.getDateTimeStamp(), event.getOccupancyAfterMark());
     }
 }
 
diff --git a/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/GarbageCollectionEventSourceTest.java b/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/GarbageCollectionEventSourceTest.java
index 9c852bf..6ffdaf5 100644
--- a/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/GarbageCollectionEventSourceTest.java
+++ b/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/GarbageCollectionEventSourceTest.java
@@ -40,12 +40,13 @@ public class GarbageCollectionEventSourceTest {
         }
     }
 
-    @Test
-    public void testPlainTextFileLineCount() {
-        Path path = new TestLogFile("streaming/gc.log").getFile().toPath();
-        assertExpectedLineCountInLog(431604, new SingleGCLogFile(path));
-    }
-
+    /*
+        @Test
+        public void testPlainTextFileLineCount() {
+            Path path = new TestLogFile("gc.log").getFile().toPath();
+            assertExpectedLineCountInLog(431604, new SingleGarbageCollectionLogFile(path));
+        }
+    */
     @Test
     public void testGZipTarFileLineCount() {
         try {
@@ -86,14 +87,11 @@ public class GarbageCollectionEventSourceTest {
         }
     }
 
-    /*
-    72209 lines + EOF sentinal.
-     */
     @Test
     public void testZippedDirectoryWithRotatingLogRotatingLineCount() {
         try {
             Path path = new TestLogFile("streaming/rotating_directory.zip").getFile().toPath();
-            assertExpectedLineCountInLog(72209+1, loadLogFile(path, true));
+            assertExpectedLineCountInLog(72211, loadLogFile(path, true));
         } catch (IOException ioe) {
             fail(ioe);
         }
diff --git a/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/GarbageCollectionLogMetaDataTest.java b/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/GarbageCollectionLogMetaDataTest.java
index 4d81e4e..3353aa3 100644
--- a/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/GarbageCollectionLogMetaDataTest.java
+++ b/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/GarbageCollectionLogMetaDataTest.java
@@ -2,6 +2,7 @@
 // Licensed under the MIT License.
 package com.microsoft.gctoolkit.vertx.io;
 
+import com.microsoft.gctoolkit.io.RotatingGCLogFile;
 import com.microsoft.gctoolkit.io.RotatingLogFileMetadata;
 import com.microsoft.gctoolkit.io.SingleLogFileMetadata;
 import org.junit.jupiter.api.Test;
@@ -43,7 +44,7 @@ public class GarbageCollectionLogMetaDataTest {
         }
     }
 
-    @Test   //todo: make sure the order is correct
+    @Test
     public void testRotatingLogs() {
         try {
             Path path = new TestLogFile("rotating.zip").getFile().toPath();
@@ -63,7 +64,7 @@ public class GarbageCollectionLogMetaDataTest {
         try {
             Path path = new TestLogFile("rotating_directory.zip").getFile().toPath();
             RotatingLogFileMetadata metaData = new RotatingLogFileMetadata(path);
-            assertEquals(2, metaData.getNumberOfFiles());
+            assertEquals(5, metaData.getNumberOfFiles());
             assertFalse(metaData.isGZip());
             assertTrue(metaData.isZip());
             assertFalse(metaData.isDirectory());
diff --git a/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/StreamGarbageCollectionLogFileTest.java b/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/StreamGarbageCollectionLogFileTest.java
index 22d4bfb..3ea2f18 100644
--- a/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/StreamGarbageCollectionLogFileTest.java
+++ b/vertx/src/test/java/com/microsoft/gctoolkit/vertx/io/StreamGarbageCollectionLogFileTest.java
@@ -16,99 +16,167 @@ import static org.junit.jupiter.api.Assertions.fail;
 
 public class StreamGarbageCollectionLogFileTest {
     
-    private GCLogFile createLogFile(Path path, boolean rotating) throws IOException {
+    private GCLogFile loadLogFile(Path path, boolean rotating) throws IOException {
         return rotating ? new RotatingGCLogFile(path) : new SingleGCLogFile(path);
     }
-
+    
     @Test
-    public void testPlainGCLogLineCount() {
+    public void testPlainTextFileLineCount() {
         try {
             Path path = new TestLogFile("streaming/gc.log").getFile().toPath();
-            GCLogFile logFile = createLogFile(path,false);
-            assertEquals(1,logFile.getMetaData().getNumberOfFiles(),"file count mismatch");
-            assertExpectedLineCount(431603, logFile);
+            assertExpectedLineCount(431603, loadLogFile(path, false));
         } catch (IOException ioe) {
             fail(ioe);
         }
     }
 
     @Test
-    public void testGZipGCLogLineCount() {
+    public void testSingleLogInZipLineCount() {
         try {
-            Path path = new TestLogFile("streaming/gc.log.gz").getFile().toPath();
-            GCLogFile logFile = createLogFile(path,false);
-            assertEquals(1,logFile.getMetaData().getNumberOfFiles(),"file count mismatch");
-            assertExpectedLineCount(18304, logFile);
+            Path path = new TestLogFile("gc.log.zip").getFile().toPath();
+            assertExpectedLineCount(431603, loadLogFile(path, false));
         } catch (IOException ioe) {
             fail(ioe);
         }
     }
 
     @Test
-    public void testGZipTarGCLogLineCount() {
+    public void testRotatingLogsLineCount() {
         try {
-            Path path = new TestLogFile("streaming/gc.log.tar.gz").getFile().toPath();
-            GCLogFile logFile = createLogFile(path,false);
-            assertEquals(1,logFile.getMetaData().getNumberOfFiles(),"file count mismatch");
-            assertExpectedLineCount(410055, logFile);
+            Path path = new TestLogFile("rotating.zip").getFile().toPath();
+            assertExpectedLineCount(52029, loadLogFile(path, false));
         } catch (IOException ioe) {
             fail(ioe);
         }
     }
 
     @Test
-    public void testZipGCLogLineCount() {
+    public void testZippedDirectoryWithRotatingLogLineCount() {
         try {
-            Path path = new TestLogFile("streaming/gc.log.zip").getFile().toPath();
-            GCLogFile logFile = createLogFile(path,false);
-            assertEquals(1,logFile.getMetaData().getNumberOfFiles(),"file count mismatch");
-            assertExpectedLineCount(431603, logFile);
+            Path path = new TestLogFile("rotating_directory.zip").getFile().toPath();
+            assertExpectedLineCount(52029, loadLogFile(path, false));
         } catch (IOException ioe) {
             fail(ioe);
         }
     }
 
     @Test
-    public void testZipRotatingGCLogLineCount() {
+    public void testGZipFileLineCount() {
         try {
-            Path path = new TestLogFile("rotating.zip").getFile().toPath();
-            GCLogFile logFile = createLogFile(path,true);
-            assertEquals(2,logFile.getMetaData().getNumberOfFiles(),"file count mismatch");
-            assertExpectedLineCount(72209, logFile);
+            Path path = new TestLogFile("gc.log.gz").getFile().toPath();
+            assertExpectedLineCount(18304, loadLogFile(path, false));
         } catch (IOException ioe) {
             fail(ioe);
         }
     }
 
+    /*
+    todo: not yet implemented so test should "fail"
+     */
     @Test
-    public void testDirectoryRotatingGCLogLineCount() {
+    public void testGZipTarFileLineCount() {
         try {
-            Path path = new TestLogFile("rotating_directory").getFile().toPath();
-            GCLogFile logFile = createLogFile(path, true);
-            assertEquals(2, logFile.getMetaData().getNumberOfFiles(), "file count mismatch");
-            assertExpectedLineCount(72209, logFile);
+            Path path = new TestLogFile("gc.log.tar.gz").getFile().toPath();
+            assertExpectedLineCount(410055, loadLogFile(path, false));
+        } catch (IOException ioe) {
+            fail(ioe);
+        }
+    }
+
+    @Test
+    public void testFilesInDirectoryTotalLineCount() {
+        Path path = new TestLogFile("rotating_directory").getFile().toPath();
+        try {
+            GCLogFile logFile = loadLogFile(path, true);
+            Stream<String> stream = logFile.stream();
+            stream.close();
         } catch (IOException ioe) {
             assertEquals(ioe.getClass(), IOException.class);
         }
     }
 
     @Test
-    public void testZippedDirectoryRotatingLogLineCount() {
+    public void testPlainTextFileRotatingLineCount() {
+        Path path = new TestLogFile("gc.log").getFile().toPath();
+        try {
+            GCLogFile logFile = loadLogFile(path, true);
+            Stream<String> stream = logFile.stream();
+            stream.close();
+        } catch (IOException ioe) {
+            assertEquals(ioe.getClass(), IOException.class);
+            assertEquals("Not a rotating GC log", ioe.getMessage());
+        } catch (IllegalArgumentException iae) {
+            assertEquals("Unable to read as rotating GC log", iae.getMessage());
+        }
+    }
+
+    @Test
+    public void testSingleLogInZipRotatingLineCount() {
+        try {
+            Path path = new TestLogFile("gc.log.zip").getFile().toPath();
+            assertExpectedLineCount(431603, loadLogFile(path, true));
+        } catch (IOException ioe) {
+            fail(ioe);
+        }
+    }
+
+    @Test
+    public void testRotatingLogsRotatingLineCount() {
+        try {
+            Path path = new TestLogFile("rotating.zip").getFile().toPath();
+            assertExpectedLineCount(72209, loadLogFile(path, true));
+        } catch (IOException ioe) {
+            fail(ioe);
+        }
+    }
+
+    @Test
+    public void testZippedDirectoryWithRotatingLogRotatingLineCount() {
         try {
             Path path = new TestLogFile("rotating_directory.zip").getFile().toPath();
-            GCLogFile logFile = createLogFile(path, true);
-            assertEquals(2, logFile.getMetaData().getNumberOfFiles(), "file count mismatch");
-            assertExpectedLineCount(72209, logFile);
+            assertExpectedLineCount(72210, loadLogFile(path, true));
+        } catch (IOException ioe) {
+            fail(ioe);
+        }
+    }
+
+    @Test
+    public void testGZipFileRotatingLineCount() {
+        Path path = new TestLogFile("gc.log.gz").getFile().toPath();
+        try {
+            GCLogFile logFile = new RotatingGCLogFile(path);
+            Stream<String> stream = logFile.stream();
+            stream.close();
+        } catch (IOException ioe) {
+            assertEquals(ioe.getClass(), IOException.class);
+            assertEquals("Unable to stream GZip files. Please unzip and retry", ioe.getMessage());
+        }
+    }
+
+    /*
+    todo: not yet implemented so test should "fail"
+     */
+//    @Test
+//    public void testGZipTarFileRotating() {
+//        Path path = new TestLogFile("gc.log").getFile().toPath();
+//        assertExpectedLineCount(410055, new RotatingGarbageCollectionLogFile( Paths.get("gc.log.tar.gz")));
+//    }
+
+    @Test
+    public void testDirectoryRotating() {
+        try {
+            Path path = new TestLogFile("rotating_directory").getFile().toPath();
+            assertExpectedLineCount(72209, loadLogFile(path, true));
         } catch (IOException ioe) {
             fail(ioe);
         }
     }
 
-    private void assertExpectedLineCount(long expectedCount, GCLogFile logFile) {
+    private void assertExpectedLineCount(long expectedCount, GCLogFile directory) {
         try {
-            Stream<String> logStream = logFile.stream();
-            assertEquals(expectedCount,logStream.count());
-            logStream.close();
+            Stream<String> directoryStream = directory.stream();
+            assertEquals(expectedCount, directoryStream.count());
+            directoryStream.close();
         } catch (IOException ioe) {
             fail(ioe.getMessage());
         }
